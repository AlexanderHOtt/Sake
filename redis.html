<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>sake.redis API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sake.redis</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

__all__: typing.Final[typing.Sequence[str]] = [
    &#34;ResourceClient&#34;,
    &#34;EmojiCache&#34;,
    &#34;GuildCache&#34;,
    &#34;GuildChannelCache&#34;,
    &#34;IntegrationCache&#34;,
    &#34;InviteCache&#34;,
    &#34;MemberCache&#34;,
    &#34;MessageCache&#34;,
    &#34;PresenceCache&#34;,
    &#34;RedisCache&#34;,
    &#34;RoleCache&#34;,
    &#34;UserCache&#34;,
    &#34;VoiceStateCache&#34;,
]

import abc
import asyncio
import datetime
import enum
import itertools
import logging
import typing

import aioredis
from hikari import channels
from hikari import errors as hikari_errors
from hikari import guilds
from hikari import invites as invites_
from hikari import presences as presences_
from hikari import snowflakes
from hikari import undefined
from hikari import users
from hikari import voices
from hikari.events import channel_events
from hikari.events import guild_events
from hikari.events import member_events
from hikari.events import message_events
from hikari.events import role_events
from hikari.events import shard_events
from hikari.events import user_events
from hikari.events import voice_events
from hikari.internal import time
from yuyo import backoff

from sake import errors
from sake import marshalling
from sake import redis_iterators
from sake import traits

if typing.TYPE_CHECKING:
    import ssl as ssl_
    import types

    import aioredis.abc
    from hikari import emojis as emojis_
    from hikari import messages
    from hikari import traits as hikari_traits

_KeyT = typing.TypeVar(&#34;_KeyT&#34;)
_OtherKeyT = typing.TypeVar(&#34;_OtherKeyT&#34;)
_ValueT = typing.TypeVar(&#34;_ValueT&#34;)
_OtherValueT = typing.TypeVar(&#34;_OtherValueT&#34;)
_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.sake.redis&#34;)
&#34;&#34;&#34;Type-Hint The logger instance used by this Sake implementation.&#34;&#34;&#34;
RedisValueT = typing.Union[bytearray, bytes, float, int, str]
&#34;&#34;&#34;A type variable of the value types accepted by aioredis.&#34;&#34;&#34;
RedisMapT = typing.MutableMapping[str, RedisValueT]
&#34;&#34;&#34;A type variable of the mapping type accepted by aioredis&#34;&#34;&#34;
ResourceT = typing.TypeVar(&#34;ResourceT&#34;, bound=&#34;ResourceClient&#34;)
&#34;&#34;&#34;Type-Hint A type hint used to represent a resource client instance.&#34;&#34;&#34;
WINDOW_SIZE: typing.Final[int] = 1_000
&#34;&#34;&#34;The default size used for &#34;windowed&#34; chunking in this client.&#34;&#34;&#34;
DEFAULT_EXPIRE: typing.Final[int] = 3_600_000
&#34;&#34;&#34;The default expire time (in milliseconds) used for expiring resources of 60 minutes.&#34;&#34;&#34;
DEFAULT_FAST_EXPIRE: typing.Final[int] = 300_000
&#34;&#34;&#34;The default expire time (in milliseconds) used for expiring resources quickly of 5 minutes.&#34;&#34;&#34;
DEFAULT_INVITE_EXPIRE: typing.Final[int] = 2_592_000_000
&#34;&#34;&#34;A special case month long default expire time for invite entries without a set &#34;expire_at&#34;.&#34;&#34;&#34;
ExpireT = typing.Union[datetime.timedelta, int, float]
&#34;&#34;&#34;A type hint used to represent expire times.

These may either be the number of seconds as an int or float (where
millisecond precision is supported) or a timedelta.
&#34;&#34;&#34;


class ResourceIndex(enum.IntEnum):
    &#34;&#34;&#34;An enum of the indexes used to map cache resources to their redis databases.&#34;&#34;&#34;

    EMOJI = 0
    GUILD = 1
    CHANNEL = 2
    INVITE = 3
    MEMBER = 4
    PRESENCE = 5
    ROLE = 6
    USER = 7
    VOICE_STATE = 8
    REFERENCE = 9
    #  REFERENCE is a special case database solely used for linking other entries to other master entities.
    MESSAGE = 10
    INTEGRATION = 11


def _cast_map_window(
    window: typing.Iterable[typing.Tuple[_KeyT, _ValueT]],
    key_cast: typing.Callable[[_KeyT], _OtherKeyT],
    value_cast: typing.Callable[[_ValueT], _OtherValueT],
) -&gt; typing.Dict[_OtherKeyT, _OtherValueT]:
    return dict((key_cast(key), value_cast(value)) for key, value in window)


async def _close_client(client: aioredis.Redis) -&gt; None:
    # TODO: will we need to catch errors here?
    client.close()


def _convert_expire_time(expire: ExpireT) -&gt; int:
    &#34;&#34;&#34;Convert a timedelta, int or float expire time representation to an integer.&#34;&#34;&#34;
    if isinstance(expire, datetime.timedelta):
        return round(expire.total_seconds() * 1000)

    if isinstance(expire, int):
        return expire * 1000

    if isinstance(expire, float):
        return round(expire * 1000)

    raise ValueError(f&#34;Invalid expire time passed; expected a float, int or timedelta but got a {type(expire)!r}&#34;)


# TODO: document that it isn&#39;t guaranteed that deletion will be finished before clear command coroutines finish.
# TODO: may go back to approach where client logic and interface are separate classes
class ResourceClient(traits.Resource, abc.ABC):
    &#34;&#34;&#34;A base client which all resources in this implementation will implement.

    !!! note
        This cannot be initialised by itself and is useless alone.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware Hikari client to bind this resource client to.
    address : typing.Union[str, typing.Tuple[str, typing.Union[str, int]]
        The address to use to connect to the Redis backend server this
        resource is linked to. This may either be a string url in the form
        of `&#34;redis://localhost:4242&#34;` or a tuple of an address to a port
        in the form of `(&#34;localhost&#34;, 4242)`.

    Other Parameters
    ----------------
    dispatch : typing.Optional[hikari.traits.DispatchAware]
        The dispatcher aware Hikari client to bind this resource client to.
        This can be left as `builtins.None` to avoid this client from
        automatically registering any event listeners.
    password : typing.Optional[str]
        The password to optionally use to connect ot the backend Redis
        server.
    ssl : typing.Union[ssl.SSLContext, builtins.bool, builtins.None]
        The SSL context to use when connecting to the Redis backend server,
        this may be a context object, bool value or None to leave default
        behaviour (which will likely be no SSL).
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;__address&#34;,
        &#34;__clients&#34;,
        &#34;__marshaller&#34;,
        &#34;__dispatch&#34;,
        &#34;__metadata&#34;,
        &#34;__password&#34;,
        &#34;__rest&#34;,
        &#34;__ssl&#34;,
        &#34;__started&#34;,
    )

    def __init__(
        self,
        rest: hikari_traits.RESTAware,
        dispatch: typing.Optional[hikari_traits.DispatcherAware] = None,
        /,
        *,
        address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]],
        password: typing.Optional[str] = None,
        ssl: typing.Union[ssl_.SSLContext, bool, None] = None,
        metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
        object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None,
    ) -&gt; None:
        self.__address = address
        self.__dispatch = dispatch
        self.__clients: typing.MutableMapping[ResourceIndex, aioredis.Redis] = {}
        self.__marshaller = object_marshaller or marshalling.JSONMarshaller(rest)
        self.__metadata = metadata or {}
        self.__password = password
        self.__rest = rest
        self.__ssl = ssl
        self.__started = False

    async def __aenter__(self: ResourceT) -&gt; ResourceT:
        await self.open()
        return self

    async def __aexit__(
        self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None

    @classmethod
    @abc.abstractmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        &#34;&#34;&#34;The index for the resource which this class is linked to.

        !!! note
            This should be called on specific base classes and will not be
            accurate after inheritance.

        Returns
        -------
        ResourceIndex
            The index of the resource this class is linked to.
        &#34;&#34;&#34;
        return ()

    @property  # As a note, this will only be set if this is actively hooked into event dispatchers
    def dispatch(self) -&gt; typing.Optional[hikari_traits.DispatcherAware]:
        &#34;&#34;&#34;The dispatcher aware client this resource client is tied to, if set.

        !!! note
            If this is set then event listeners will be (de)registered
            when this resource is opened/closed.

        Returns
        -------
        typing.Optional[hikari.traits.DispatcherAware]
            The dispatcher aware client this resource is tied to if set,
            else `builtins.None`.
        &#34;&#34;&#34;
        return self.__dispatch

    @property
    def marshaller(self) -&gt; marshalling.ObjectMarshaller[bytes]:
        return self.__marshaller

    @property
    def metadata(self) -&gt; typing.MutableMapping[str, typing.Any]:
        return self.__metadata

    @property  # unlike here where this is 100% required for building models.
    def rest(self) -&gt; hikari_traits.RESTAware:
        &#34;&#34;&#34;The REST aware client this resource client is tied to.

        This is used to build models with a `app` attribute.

        Returns
        -------
        hikari.traits.RESTAware
            The REST aware client this resource is tied to.
        &#34;&#34;&#34;
        return self.__rest

    async def get_connection(self, resource: ResourceIndex, /) -&gt; aioredis.Redis:
        &#34;&#34;&#34;Get the connection for a specific resource.

        Parameters
        ----------
        resource : ResourceIndex
            The index of the resource to get a connection for.

        Returns
        -------
        aioredis.Redis
            The connection instance for the specified resource.

        Raises
        ------
        TypeError
            When this method is called on a closed client.
        ValueError
            When you pass an invalid resource for the client.
        &#34;&#34;&#34;
        if not self.__started:
            raise TypeError(&#34;Cannot use an inactive client&#34;)

        try:
            return self.__clients[resource]
        except KeyError:
            raise ValueError(f&#34;Resource index `{resource}` is invalid for this client&#34;) from None

    @classmethod
    def _get_indexes(cls) -&gt; typing.MutableSet[ResourceIndex]:
        results: typing.Set[ResourceIndex] = set()
        for sub_class in cls.mro():
            if issubclass(sub_class, ResourceClient):
                results.update(sub_class.index())

        return results

    async def get_connection_status(self, resource: ResourceIndex, /) -&gt; bool:
        &#34;&#34;&#34;Get the status of the internal connection for a specific resource.

        Parameters
        ----------
        resource : ResourceIndex
            The index of the resource to get the status for.

        Returns
        -------
        bool
            Whether the client has an active connection for the specified resource.
        &#34;&#34;&#34;
        return resource in self.__clients and not self.__clients[resource].closed

    async def _optionally_bulk_set_users(self, users_: typing.Iterator[users.User]) -&gt; None:
        try:
            client = await self.get_connection(ResourceIndex.USER)
        except ValueError:
            pass
        else:
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))
            # user_setters = []
            # expire_setters: typing.MutableSequence[typing.Coroutine[typing.Any, typing.Any, None]] = []

            for window in redis_iterators.chunk_values(users_):
                processed_window = {int(user.id): self.marshaller.serialize_user(user) for user in window}
                # transaction = client.multi_exec()
                #
                # for user_id in processed_window.keys():
                #     transaction.pexpire(user_id, expire_time)
                #
                # expire_setters.append(transaction.execute())
                await client.mset(processed_window)
                asyncio.gather(*(client.pexpire(user_id, expire_time) for user_id in processed_window.keys()))
                #  TODO: benchmark bulk setting expire with transaction vs this
                # user_setters.append(client.mset(processed_window))
                # expire_setters.extend((client.pexpire(user_id, expire_time) for user_id in processed_window.keys()))

            # asyncio.gather(*user_setters)
            # asyncio.gather(*expire_setters)

    async def _optionally_set_user(self, user: users.User) -&gt; None:
        try:
            client = await self.get_connection(ResourceIndex.USER)
        except ValueError:
            pass
        else:
            data = self.marshaller.serialize_user(user)
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))
            await client.set(int(user.id), data, pexpire=expire_time)

    async def _spawn_connection(self, resource: ResourceIndex) -&gt; None:
        self.__clients[resource] = await aioredis.create_redis_pool(
            address=self.__address,
            db=int(resource),
            password=self.__password,
            ssl=self.__ssl,
            # encoding=&#34;utf-8&#34;,
        )

    async def open(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        if self.__started:
            return

        try:
            # Gather is awaited here so we can assure all clients are started before this returns.
            await asyncio.gather(*map(self._spawn_connection, self._get_indexes()))
        except aioredis.RedisError:
            # Ensure no dangling clients are left if this fails to start.
            clients = self.__clients
            self.__clients = {}
            await asyncio.gather(*map(_close_client, clients.values()))
            raise

        self.subscribe_listeners()
        self.__started = True

    async def close(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # We want to ensure that we both only do anything here if the client was already started when the method was
        # originally called and also that the client is marked as &#34;closed&#34; before this starts severing connections.
        was_started = self.__started
        self.__started = False

        if not was_started:
            return

        self.unsubscribe_listeners()
        clients = self.__clients
        self.__clients = {}
        # Gather is awaited here so we can assure all clients are closed before this returns.
        await asyncio.gather(*map(_close_client, clients.values()))

    @abc.abstractmethod
    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return None

    @abc.abstractmethod
    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return None


class _Reference(ResourceClient, abc.ABC):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.REFERENCE,)

    @staticmethod
    def _generate_reference_key(master: ResourceIndex, master_id: snowflakes.Snowflakeish, slave: ResourceIndex) -&gt; str:
        return f&#34;{int(master)}:{master_id}:{int(slave)}&#34;

    # To ensure at least 1 ID is always provided we have a required arg directly before the variable-length argument.
    async def _add_ids(
        self,
        master: ResourceIndex,
        master_id: snowflakes.Snowflakeish,
        slave: ResourceIndex,
        identifier: RedisValueT,
        *identifiers: RedisValueT,
    ) -&gt; None:
        key = self._generate_reference_key(master, master_id, slave)
        client = await self.get_connection(ResourceIndex.REFERENCE)
        await client.sadd(key, identifier, *identifiers)

    # To ensure at least 1 ID is always provided we have a required arg directly before the variable-length argument.
    async def _delete_ids(
        self,
        master: ResourceIndex,
        master_id: snowflakes.Snowflakeish,
        slave: ResourceIndex,
        identifier: RedisValueT,
        *identifiers: RedisValueT,
        reference_key: bool = False,
    ) -&gt; None:
        key = self._generate_reference_key(master, master_id, slave)
        client = await self.get_connection(ResourceIndex.REFERENCE)
        await client.srem(key, identifier, *identifiers)  # TODO: do i need to explicitly delete this if len is 0?

        if reference_key and await client.scard(key) == 1:
            await client.delete(key)

    async def _dump_relationship(
        self, master: ResourceIndex, slave: ResourceIndex
    ) -&gt; typing.MutableMapping[bytes, typing.MutableSequence[bytes]]:
        client = await self.get_connection(ResourceIndex.REFERENCE)
        keys = await client.keys(pattern=f&#34;{master}:*:{slave}&#34;)
        values = await asyncio.gather(*map(client.smembers, keys))
        references = {keys[index]: value for index, value in enumerate(values)}
        asyncio.gather(*(client.srem(key, *members) for key, members in references.items() if members))
        return references

    async def _get_ids(
        self,
        master: ResourceIndex,
        master_id: snowflakes.Snowflakeish,
        slave: ResourceIndex,
        *,
        cast: typing.Callable[[bytes], _ValueT],
    ) -&gt; typing.MutableSequence[_ValueT]:
        key = self._generate_reference_key(master, master_id, slave)
        client = await self.get_connection(ResourceIndex.REFERENCE)
        return [*map(cast, await client.smembers(key))]


# To avoid breaking Mro conflicts this is kept as a separate class despite only being exposed through the UserCache.
class _MeCache(ResourceClient, traits.MeCache):
    __slots__: typing.Sequence[str] = ()

    __ME_KEY: typing.Final[str] = &#34;ME&#34;

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        # This isn&#39;t a full MeCache implementation in itself as it&#39;s reliant on the UserCache implementation.
        return ()

    async def __on_own_user_update(self, event: user_events.OwnUserUpdateEvent) -&gt; None:
        await self.set_me(event.user)

    async def __on_shard_ready(self, event: shard_events.ShardReadyEvent) -&gt; None:
        await self.set_me(event.my_user)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(user_events.OwnUserUpdateEvent, self.__on_own_user_update)
            self.dispatch.dispatcher.subscribe(shard_events.ShardReadyEvent, self.__on_shard_ready)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(user_events.OwnUserUpdateEvent, self.__on_own_user_update)
            self.dispatch.dispatcher.subscribe(shard_events.ShardReadyEvent, self.__on_shard_ready)

    async def delete_me(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MeCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        await client.delete(self.__ME_KEY)

    async def get_me(self) -&gt; users.OwnUser:
        # &lt;&lt;Inherited docstring from sake.traits.MeCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        data = await client.get(self.__ME_KEY)

        if not data:
            raise errors.EntryNotFound(&#34;Me entry not found&#34;)

        return self.marshaller.deserialize_own_user(data)

    async def set_me(self, me: users.OwnUser, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MeCache&gt;&gt;
        data = self.marshaller.serialize_own_user(me)
        client = await self.get_connection(ResourceIndex.USER)
        await client.set(self.__ME_KEY, data)
        await self._optionally_set_user(me)


class UserCache(_MeCache, traits.UserCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.USER,)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # The users cache is a special case as it doesn&#39;t directly map to any events for most user entries.
        super().subscribe_listeners()

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # The users cache is a special case as it doesn&#39;t directly map to any events for most user entries.
        super().unsubscribe_listeners()

    def with_user_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for user entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for users in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_user&#34;] = _convert_expire_time(expire)

        elif &#34;expire_user&#34; in self.metadata:
            del self.metadata[&#34;expire_user&#34;]

        return self

    async def clear_users(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        await client.flushdb()

    async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        await client.delete(int(user_id))

    async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.USER)
        data = await client.get(user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;User entry `{user_id}` not found&#34;)

        return self.marshaller.deserialize_user(data)

    def iter_users(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[users.User]:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.USER, self.marshaller.deserialize_user, window_size=window_size
        )

    async def set_user(self, user: users.User, /, *, expire_time: typing.Optional[ExpireT] = None) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        await client.set(int(user.id), self.marshaller.serialize_user(user), pexpire=expire_time)


class EmojiCache(_Reference, traits.RefEmojiCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.EMOJI,)

    async def __bulk_add_emojis(
        self, emojis: typing.Iterable[emojis_.KnownCustomEmoji], guild_id: snowflakes.Snowflake
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.EMOJI)
        windows = redis_iterators.chunk_values(emojis)
        setters = (
            client.mset({int(emoji.id): self.marshaller.serialize_emoji(emoji) for emoji in window})
            for window in windows
        )
        user_setter = self._optionally_bulk_set_users(emoji.user for emoji in emojis if emoji.user is not None)
        reference_setter = self._add_ids(
            ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, *(int(emoji.id) for emoji in emojis)
        )
        asyncio.gather(*setters, user_setter, reference_setter)

    async def __on_emojis_update(self, event: guild_events.EmojisUpdateEvent) -&gt; None:
        await self.clear_emojis_for_guild(event.guild_id)

        if event.emojis:
            await self.__bulk_add_emojis(event.emojis, event.guild_id)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_emojis_for_guild(event.guild_id)
        if isinstance(event, (guild_events.GuildAvailableEvent, guild_events.GuildUpdateEvent)) and event.emojis:
            await self.__bulk_add_emojis(event.emojis.values(), event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.EmojisUpdateEvent, self.__on_emojis_update)
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            #  TODO: can we also listen for member delete to manage this?

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.EmojisUpdateEvent, self.__on_emojis_update)
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            #  TODO: can we also listen for member delete to manage this?

    async def clear_emojis(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.EMOJI)
        client = await self.get_connection(ResourceIndex.EMOJI)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(emoji_ids))))

    async def clear_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, cast=bytes)
        if not emoji_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, *emoji_ids)
        client = await self.get_connection(ResourceIndex.EMOJI)
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(emoji_ids)))

    async def delete_emoji(
        self, emoji_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_id = int(emoji_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_emoji(emoji_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.EMOJI)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, emoji_id)
        await client.delete(emoji_id)

    async def get_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; emojis_.KnownCustomEmoji:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_id = int(emoji_id)
        client = await self.get_connection(ResourceIndex.EMOJI)
        data = await client.get(emoji_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Emoji entry `{emoji_id}` not found&#34;)

        return self.marshaller.deserialize_emoji(data)

    def iter_emojis(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[emojis_.KnownCustomEmoji]:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.EMOJI, self.marshaller.deserialize_emoji, window_size=window_size
        )

    def iter_emojis_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[emojis_.KnownCustomEmoji]:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.EMOJI, self.marshaller.deserialize_emoji, window_size=window_size
        )

    async def set_emoji(self, emoji: emojis_.KnownCustomEmoji, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.EMOJI)
        data = self.marshaller.serialize_emoji(emoji)
        await self._add_ids(ResourceIndex.GUILD, emoji.guild_id, ResourceIndex.EMOJI, int(emoji.id))
        await client.set(int(emoji.id), data)

        if emoji.user is not None:
            await self._optionally_set_user(emoji.user)


class GuildCache(ResourceClient, traits.GuildCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.GUILD,)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        client = await self.get_connection(ResourceIndex.GUILD)
        if isinstance(event, guild_events.GuildAvailableEvent):
            data = self.marshaller.serialize_guild(event.guild)
            await client.set(int(event.guild_id), data)

        elif isinstance(event, guild_events.GuildLeaveEvent):
            await client.delete(int(event.guild_id))

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    async def clear_guilds(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        await client.flushdb()

    async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        await client.delete(int(guild_id))

    async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        guild_id = int(guild_id)
        client = await self.get_connection(ResourceIndex.GUILD)
        data = await client.get(guild_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Guild entry `{guild_id}` not found&#34;)

        return self.marshaller.deserialize_guild(data)

    def iter_guilds(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.GatewayGuild]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.GUILD, self.marshaller.deserialize_guild, window_size=window_size
        )

    async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        data = self.marshaller.serialize_guild(guild)
        await client.set(int(guild.id), data)


class GuildChannelCache(_Reference, traits.RefGuildChannelCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.CHANNEL,)

    async def __on_guild_channel_event(self, event: channel_events.GuildChannelEvent) -&gt; None:
        if isinstance(event, (channel_events.GuildChannelCreateEvent, channel_events.GuildChannelUpdateEvent)):
            await self.set_guild_channel(event.channel)

        elif isinstance(event, channel_events.GuildChannelDeleteEvent):
            await self.delete_guild_channel(event.channel_id, guild_id=event.guild_id)

        elif isinstance(event, channel_events.GuildPinsUpdateEvent):
            try:
                channel = await self.get_guild_channel(event.channel_id)
            except errors.EntryNotFound:
                pass
            else:
                assert isinstance(
                    channel, (channels.GuildNewsChannel, channels.GuildTextChannel)
                ), &#34;unexpected channel type for a pin update&#34;
                channel.last_pin_timestamp = event.last_pin_timestamp
                await self.set_guild_channel(channel)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_guild_channels_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.channels:
            client = await self.get_connection(ResourceIndex.CHANNEL)
            windows = redis_iterators.chunk_values(event.channels.items())
            setters = (
                client.mset(_cast_map_window(window, int, self.marshaller.serialize_guild_channel))
                for window in windows
            )
            id_setter = self._add_ids(
                ResourceIndex.GUILD, event.guild_id, ResourceIndex.CHANNEL, *map(int, event.channels.keys())
            )
            asyncio.gather(*setters, id_setter)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(channel_events.GuildChannelEvent, self.__on_guild_channel_event)
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(channel_events.GuildChannelEvent, self.__on_guild_channel_event)
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    async def clear_guild_channels(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.CHANNEL)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(channel_ids))))

    async def clear_guild_channels_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        guild_id = int(guild_id)
        channel_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, cast=bytes)
        if not channel_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, *channel_ids)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        #  TODO: is there any benefit to chunking on bulk delete?
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(channel_ids)))

    async def delete_guild_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_id = int(channel_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_guild_channel(channel_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.CHANNEL)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, channel_id)
        await client.delete(channel_id)

    async def get_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; channels.GuildChannel:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_id = int(channel_id)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        data = await client.get(channel_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Guild channel entry `{channel_id}` not found&#34;)

        return self.marshaller.deserialize_guild_channel(data)

    def iter_guild_channels(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[channels.GuildChannel]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.CHANNEL, self.marshaller.deserialize_guild_channel, window_size=window_size
        )

    def iter_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[channels.GuildChannel]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.CHANNEL, self.marshaller.deserialize_guild_channel, window_size=window_size
        )

    async def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.CHANNEL)
        data = self.marshaller.serialize_guild_channel(channel)
        await client.set(int(channel.id), data)
        await self._add_ids(ResourceIndex.GUILD, int(channel.guild_id), ResourceIndex.CHANNEL, int(channel.id))


class IntegrationCache(_Reference, traits.IntegrationCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.INTEGRATION,)

    async def __on_guild_leave_event(self, event: guild_events.GuildLeaveEvent) -&gt; None:
        await self.clear_integrations_for_guild(event.guild_id)

    async def __on_integration_event(self, event: guild_events.IntegrationEvent) -&gt; None:
        if isinstance(event, (guild_events.IntegrationCreateEvent, guild_events.IntegrationUpdateEvent)):
            await self.set_integration(event.integration)

        elif isinstance(event, guild_events.IntegrationDeleteEvent):
            await self.delete_integration(event.id, guild_id=event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildLeaveEvent, self.__on_guild_leave_event)
            self.dispatch.dispatcher.subscribe(guild_events.IntegrationEvent, self.__on_integration_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildLeaveEvent, self.__on_guild_leave_event)
            self.dispatch.dispatcher.unsubscribe(guild_events.IntegrationEvent, self.__on_integration_event)

    async def clear_integrations(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.INTEGRATION)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids)))

    async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        guild_id = int(guild_id)
        ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, cast=bytes)
        if not ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, *ids)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids)))

    async def delete_integration(
        self, integration_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        integration_id = int(integration_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_integration(integration_id)).guild_id
            except errors.EntryNotFound:
                return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, integration_id)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        await client.delete(integration_id)

    async def get_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; guilds.Integration:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        data = await client.get(int(integration_id))

        if not data:
            raise errors.EntryNotFound(f&#34;Integration entry `{integration_id}` not found&#34;)

        return self.marshaller.deserialize_integration(data)

    def iter_integrations(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Integration]:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.INTEGRATION, builder=self.marshaller.deserialize_integration, window_size=window_size
        )

    def iter_integrations_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Integration]:
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION).encode()
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.INTEGRATION, self.marshaller.deserialize_integration, window_size=window_size
        )

    async def set_integration(self, integration: guilds.Integration, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        data = self.marshaller.serialize_integration(integration)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        await client.set(int(integration.id), data)
        await self._add_ids(ResourceIndex.GUILD, integration.guild_id, ResourceIndex.INTEGRATION, int(integration.id))


class InviteCache(ResourceClient, traits.InviteCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.INVITE,)

    async def __on_invite_event(self, event: channel_events.InviteEvent) -&gt; None:
        if isinstance(event, channel_events.InviteCreateEvent):
            await self.set_invite(event.invite)

        elif isinstance(event, channel_events.InviteDeleteEvent):
            await self.delete_invite(event.code)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(channel_events.InviteEvent, self.__on_invite_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(channel_events.InviteEvent, self.__on_invite_event)

    def with_invite_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for invite entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for invites in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_invite&#34;] = _convert_expire_time(expire)

        elif &#34;expire_invite&#34; in self.metadata:
            del self.metadata[&#34;expire_invite&#34;]

        return self

    async def clear_invites(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        await client.flushdb()

    async def delete_invite(self, invite_code: str, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        await client.delete(str(invite_code))

    async def get_invite(self, invite_code: str, /) -&gt; invites_.InviteWithMetadata:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        invite_code = str(invite_code)
        client = await self.get_connection(ResourceIndex.INVITE)
        data = await client.get(invite_code)
        if not data:
            raise errors.EntryNotFound(f&#34;Invite entry `{invite_code}` not found&#34;)

        return self.marshaller.deserialize_invite(data)

    def iter_invites(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[invites_.InviteWithMetadata]:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.INVITE, self.marshaller.deserialize_invite, window_size=window_size
        )

    async def set_invite(
        self, invite: invites_.InviteWithMetadata, /, *, expire_time: typing.Optional[ExpireT] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        data = self.marshaller.serialize_invite(invite)

        if expire_time is None and invite.expires_at is not None:
            expire_time = round((invite.expires_at - time.utc_datetime()).total_seconds() * 1000)

            # If this invite has already expired or the system clock is direly out of sync then we cannot
            # use the expire time we just calculated.
            if expire_time &lt;= 0:
                expire_time = None

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_invite&#34;, DEFAULT_INVITE_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        await client.set(str(invite.code), data, pexpire=expire_time)

        if invite.target_user is not None:
            await self._optionally_set_user(invite.target_user)

        if invite.inviter is not None:
            await self._optionally_set_user(invite.inviter)


class MemberCache(ResourceClient, traits.MemberCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.MEMBER,)

    async def __bulk_add_members(
        self, guild_id: snowflakes.Snowflakeish, members: typing.Mapping[snowflakes.Snowflake, guilds.Member]
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.MEMBER)
        windows = redis_iterators.chunk_values(members.items())
        setters = (
            client.hmset_dict(int(guild_id), _cast_map_window(window, int, self.marshaller.serialize_member))
            for window in windows
        )
        user_setter = self._optionally_bulk_set_users(member.user for member in members.values())
        asyncio.gather(*setters, user_setter)

    async def __on_guild_availability(self, event: guild_events.GuildAvailableEvent) -&gt; None:
        await self.clear_members_for_guild(event.guild_id)
        if event.members:
            await self.__bulk_add_members(event.guild_id, event.members)

    async def __on_member_event(self, event: member_events.MemberEvent) -&gt; None:
        if isinstance(event, (member_events.MemberCreateEvent, member_events.MemberUpdateEvent)):
            await self.set_member(event.member)

        elif isinstance(event, member_events.MemberDeleteEvent):
            back_off = backoff.Backoff()
            async for _ in back_off:
                if &#34;own_id&#34; in self.metadata:
                    break

                try:
                    user = await self.rest.rest.fetch_my_user()

                except hikari_errors.RateLimitedError as exc:
                    back_off.set_next_backoff(exc.retry_after)

                except hikari_errors.InternalServerError:
                    pass

                else:
                    self.metadata[&#34;own_id&#34;] = user.id
                    break

            own_id = snowflakes.Snowflake(self.metadata[&#34;own_id&#34;])
            if event.user_id == own_id:
                await self.clear_members_for_guild(event.guild_id)
            else:
                await self.delete_member(event.guild_id, event.user_id)

    async def __on_member_chunk_event(self, event: shard_events.MemberChunkEvent) -&gt; None:
        await self.__bulk_add_members(event.guild_id, event.members)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildAvailableEvent, self.__on_guild_availability)
            self.dispatch.dispatcher.subscribe(member_events.MemberEvent, self.__on_member_event)
            self.dispatch.dispatcher.subscribe(shard_events.MemberChunkEvent, self.__on_member_chunk_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildAvailableEvent, self.__on_guild_availability)
            self.dispatch.dispatcher.unsubscribe(member_events.MemberEvent, self.__on_member_event)
            self.dispatch.dispatcher.unsubscribe(shard_events.MemberChunkEvent, self.__on_member_chunk_event)

    async def clear_members(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.flushdb()

    async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.delete(int(guild_id))

    async def delete_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.hdel(int(guild_id), int(user_id))

    async def get_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; guilds.Member:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        guild_id = int(guild_id)
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.MEMBER)
        data = await client.hget(guild_id, user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Member entry `{user_id}` not found for guild `{guild_id}`&#34;)

        return self.marshaller.deserialize_member(data)

    def iter_members(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Member]:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.MEMBER, self.marshaller.deserialize_member, window_size=window_size
        )

    def iter_members_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Member]:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.MEMBER,
            self.marshaller.deserialize_member,
            window_size=window_size,
        )

    async def set_member(self, member: guilds.Member, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        data = self.marshaller.serialize_member(member)
        await client.hset(int(member.guild_id), int(member.user.id), data)
        await self._optionally_set_user(member.user)


class MessageCache(ResourceClient, traits.MessageCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.MESSAGE,)

    async def __on_message_event(self, event: message_events.MessageEvent) -&gt; None:
        if isinstance(event, message_events.MessageCreateEvent):
            await self.set_message(event.message)

        elif isinstance(event, message_events.MessageUpdateEvent):
            await self.update_message(event.message)

        elif isinstance(event, message_events.MessageDeleteEvent):
            client = await self.get_connection(ResourceIndex.MESSAGE)
            asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(map(int, event.message_ids))))

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(message_events.MessageEvent, self.__on_message_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(message_events.MessageEvent, self.__on_message_event)

    def with_message_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for message entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for messages in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_message&#34;] = _convert_expire_time(expire)

        elif &#34;expire_message&#34; in self.metadata:
            del self.metadata[&#34;expire_message&#34;]

        return self

    async def clear_messages(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        await client.flushdb()

    async def delete_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MESSAGE)
        await client.delete(int(message_id))

    async def get_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; messages.Message:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        message_id = int(message_id)
        client = await self.get_connection(ResourceIndex.MESSAGE)
        data = await client.get(message_id)
        if not data:
            raise errors.EntryNotFound(f&#34;Message entry `{message_id}` not found&#34;)

        return self.marshaller.deserialize_message(data)

    def iter_messages(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[messages.Message]:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.MESSAGE, self.marshaller.deserialize_message, window_size=window_size
        )

    async def set_message(self, message: messages.Message, /, *, expire_time: typing.Optional[ExpireT] = None) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        data = await self.marshaller.serialize_message(message)
        client = await self.get_connection(ResourceIndex.MESSAGE)

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_message&#34;, DEFAULT_FAST_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        await client.set(int(message.id), data, expire=expire_time)
        await self._optionally_set_user(message.author)

    async def update_message(self, message: messages.PartialMessage, /) -&gt; bool:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        # This is a special case method for handling the partial message updates we get
        try:
            full_message = await self.get_message(message.id)
        except errors.EntryNotFound:
            return False

        if message.content is not undefined.UNDEFINED:
            full_message.content = message.content

        if message.timestamp is not undefined.UNDEFINED:
            full_message.timestamp = message.timestamp

        if message.edited_timestamp is not undefined.UNDEFINED:
            full_message.edited_timestamp = message.edited_timestamp

        if message.is_tts is not undefined.UNDEFINED:
            full_message.is_tts = message.is_tts

        if message.is_mentioning_everyone is not undefined.UNDEFINED:
            full_message.is_mentioning_everyone = message.is_mentioning_everyone

        if message.user_mentions is not undefined.UNDEFINED:
            full_message.user_mentions = message.user_mentions

        if message.role_mentions is not undefined.UNDEFINED:
            full_message.role_mentions = message.role_mentions

        if message.channel_mentions is not undefined.UNDEFINED:
            full_message.channel_mentions = message.channel_mentions

        if message.attachments is not undefined.UNDEFINED:
            full_message.attachments = message.attachments

        if message.embeds is not undefined.UNDEFINED:
            full_message.embeds = message.embeds

        if message.reactions is not undefined.UNDEFINED:
            full_message.reactions = message.reactions

        if message.is_pinned is not undefined.UNDEFINED:
            full_message.is_pinned = message.is_pinned

        if message.webhook_id is not undefined.UNDEFINED:
            full_message.webhook_id = message.webhook_id

        if message.type is not undefined.UNDEFINED:
            full_message.type = message.type

        if message.activity is not undefined.UNDEFINED:
            full_message.activity = message.activity

        if message.application is not undefined.UNDEFINED:
            full_message.application = message.application

        if message.message_reference is not undefined.UNDEFINED:
            full_message.message_reference = message.message_reference

        if message.flags is not undefined.UNDEFINED:
            full_message.flags = message.flags

        if message.nonce is not undefined.UNDEFINED:
            full_message.nonce = message.nonce

        await self.set_message(full_message)
        return True


class PresenceCache(ResourceClient, traits.PresenceCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.PRESENCE,)

    async def __bulk_add_presences(
        self, guild_id: snowflakes.Snowflake, presences: typing.Mapping[snowflakes.Snowflake, presences_.MemberPresence]
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.PRESENCE)
        windows = redis_iterators.chunk_values(presences.items())
        setters = (
            client.hmset_dict(int(guild_id), _cast_map_window(window, int, self.marshaller.serialize_presence))
            for window in windows
        )
        asyncio.gather(*setters)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_presences_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.presences:
            await self.__bulk_add_presences(event.guild_id, event.presences)

    async def __on_member_chunk(self, event: shard_events.MemberChunkEvent) -&gt; None:
        await self.__bulk_add_presences(event.guild_id, event.presences)

    async def __on_presence_update_event(self, event: guild_events.PresenceUpdateEvent) -&gt; None:
        if event.presence.visible_status is presences_.Status.OFFLINE:
            await self.delete_presence(event.guild_id, event.user_id)
            # TODO: handle presence.user?

        else:
            await self.set_presence(event.presence)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(shard_events.MemberChunkEvent, self.__on_member_chunk)
            self.dispatch.dispatcher.subscribe(guild_events.PresenceUpdateEvent, self.__on_presence_update_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(shard_events.MemberChunkEvent, self.__on_member_chunk)
            self.dispatch.dispatcher.unsubscribe(guild_events.PresenceUpdateEvent, self.__on_presence_update_event)

    async def clear_presences(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.flushdb()

    async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.delete(int(guild_id))

    async def delete_presence(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.hdel(int(guild_id), int(user_id))

    async def get_presence(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; presences_.MemberPresence:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        data = await client.hget(int(guild_id), int(user_id))
        return self.marshaller.deserialize_presence(data)

    def iter_presences(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[presences_.MemberPresence]:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.PRESENCE, self.marshaller.deserialize_presence, window_size=window_size
        )

    def iter_presences_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[presences_.MemberPresence]:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.PRESENCE,
            self.marshaller.deserialize_presence,
            window_size=window_size,
        )

    async def set_presence(self, presence: presences_.MemberPresence, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        data = self.marshaller.serialize_presence(presence)
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.hset(int(presence.guild_id), int(presence.user_id), data)


class RoleCache(_Reference, traits.RoleCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.ROLE,)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_roles_for_guild(event.guild_id)
        if isinstance(event, (guild_events.GuildAvailableEvent, guild_events.GuildUpdateEvent)) and event.emojis:
            client = await self.get_connection(ResourceIndex.ROLE)
            windows = redis_iterators.chunk_values(event.roles.items())
            setters = (client.mset(_cast_map_window(window, int, self.marshaller.serialize_role)) for window in windows)
            id_setter = self._add_ids(
                ResourceIndex.GUILD, event.guild_id, ResourceIndex.ROLE, *map(int, event.roles.keys())
            )
            asyncio.gather(*setters, id_setter)

    async def __on_role_update(self, event: role_events.RoleEvent) -&gt; None:
        if isinstance(event, (role_events.RoleCreateEvent, role_events.RoleUpdateEvent)):
            await self.set_role(event.role)

        elif isinstance(event, role_events.RoleDeleteEvent):
            await self.delete_role(event.role_id, guild_id=event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(role_events.RoleEvent, self.__on_role_update)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(role_events.RoleEvent, self.__on_role_update)

    async def clear_roles(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        references = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.ROLE)
        client = await self.get_connection(ResourceIndex.ROLE)
        asyncio.gather(
            *itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(references.values())))
        )

    async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, cast=bytes)
        if not role_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, *role_ids)
        client = await self.get_connection(ResourceIndex.ROLE)
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(role_ids)))

    async def delete_role(
        self, role_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_id = int(role_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_role(role_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.ROLE)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, role_id)
        await client.delete(role_id)

    async def get_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; guilds.Role:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_id = int(role_id)
        client = await self.get_connection(ResourceIndex.ROLE)
        data = await client.get(role_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Role entry `{role_id}` not found&#34;)

        return self.marshaller.deserialize_role(data)

    def iter_roles(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Role]:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.ROLE, self.marshaller.deserialize_role, window_size=window_size
        )

    def iter_roles_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Role]:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.ROLE, self.marshaller.deserialize_role, window_size=window_size
        )

    async def set_role(self, role: guilds.Role, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.ROLE)
        await client.set(int(role.id), self.marshaller.serialize_role(role))
        await self._add_ids(ResourceIndex.GUILD, role.guild_id, ResourceIndex.ROLE, int(role.id))


class VoiceStateCache(_Reference, traits.VoiceStateCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.VOICE_STATE,)

    async def __on_guild_channel_delete_event(self, event: channel_events.GuildChannelDeleteEvent) -&gt; None:
        await self.clear_voice_states_for_channel(event.channel_id)

    @staticmethod
    def __generate_references(
        voice_states: typing.Iterable[voices.VoiceState],
        *,
        include_reference_key: bool,
    ) -&gt; typing.MutableMapping[snowflakes.Snowflake, typing.MutableSet[str]]:
        references: typing.MutableMapping[snowflakes.Snowflake, typing.MutableSet[str]] = {}
        for state in voice_states:
            assert state.channel_id is not None, &#34;This channel ID shouldn&#39;t ever be None&#34;
            if state.channel_id not in references:
                references[state.channel_id] = set()
                if not include_reference_key:
                    continue

                references[state.channel_id].add(redis_iterators.HashReferenceIterator.hash_key(state.guild_id))

            references[state.channel_id].add(str(state.user_id))

        return references

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_voice_states_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.voice_states:
            client = await self.get_connection(ResourceIndex.VOICE_STATE)
            windows = redis_iterators.chunk_values(event.voice_states.items())
            setters = (
                client.hmset_dict(
                    int(event.guild_id), _cast_map_window(window, int, self.marshaller.serialize_voice_state)
                )
                for window in windows
            )

            references = self.__generate_references(event.voice_states.values(), include_reference_key=True)
            reference_setters = (
                self._add_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, *state_ids)
                for channel_id, state_ids in references.items()
                if state_ids
            )
            user_setter = self._optionally_bulk_set_users(state.member.user for state in event.voice_states.values())
            asyncio.gather(*setters, user_setter, *reference_setters)

    async def __on_voice_state_update(self, event: voice_events.VoiceStateUpdateEvent) -&gt; None:
        if event.state.channel_id is None:
            await self.delete_voice_state(event.state.guild_id, event.state.user_id)
        else:
            await self.set_voice_state(event.state)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(
                channel_events.GuildChannelDeleteEvent, self.__on_guild_channel_delete_event
            )
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(voice_events.VoiceStateUpdateEvent, self.__on_voice_state_update)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(
                channel_events.GuildChannelDeleteEvent, self.__on_guild_channel_delete_event
            )
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(voice_events.VoiceStateUpdateEvent, self.__on_voice_state_update)

    @staticmethod
    def _pop_reference(keys: typing.MutableSequence[bytes]) -&gt; typing.Tuple[bytes, typing.Sequence[bytes]]:
        for key in keys:
            if key.startswith(b&#34;KEY.&#34;):
                keys.remove(key)
                return key[4:], keys

        raise ValueError(&#34;Couldn&#39;t find reference key&#34;)

    async def clear_voice_states(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        references = await self._dump_relationship(ResourceIndex.CHANNEL, ResourceIndex.VOICE_STATE)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        asyncio.gather(
            *(client.hdel(key, *values) for key, values in map(self._pop_reference, references.values()) if values)
        )

    async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        states = await self.iter_voice_states_for_guild(guild_id)
        references = self.__generate_references(states, include_reference_key=False)
        id_deleters = (
            self._delete_ids(ResourceIndex.CHANNEL, key, ResourceIndex.VOICE_STATE, *values, reference_key=True)
            for key, values in references.items()
            if values
        )
        entry_deleters = (
            client.hdel(int(guild_id), *values)
            for values in redis_iterators.chunk_values(int(state.user_id) for state in states)
        )
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*id_deleters, *entry_deleters)

    async def clear_voice_states_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        ids = await self._get_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, cast=bytes)
        if not ids:
            return

        await self._delete_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, *ids, reference_key=True)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids, window_size=window_size)))

    # We don&#39;t accept channel_id here to avoid the relationship lookup as channel_id isn&#39;t a static value and what we
    # want is the value stored rather than the current or &#34;last&#34; value.
    async def delete_voice_state(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)

        try:
            voice_state = await self.get_voice_state(guild_id, user_id)
        except errors.EntryNotFound:
            pass
        else:
            assert voice_state.channel_id is not None, &#34;Cached voice states should always have a bound channel&#34;
            await client.hdel(int(guild_id), user_id)
            await self._delete_ids(
                ResourceIndex.CHANNEL,
                voice_state.channel_id,
                ResourceIndex.VOICE_STATE,
                user_id,
                reference_key=True,
            )

    async def get_voice_state(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; voices.VoiceState:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        guild_id = int(guild_id)
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        data = await client.hget(guild_id, user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Voice state entry `{user_id}` not found for guild `{guild_id}`&#34;)

        return self.marshaller.deserialize_voice_state(data)

    def iter_voice_states(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.VOICE_STATE, self.marshaller.deserialize_voice_state, window_size=window_size
        )

    def iter_voice_states_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE)
        return redis_iterators.HashReferenceIterator(
            self,
            key,
            index=ResourceIndex.VOICE_STATE,
            builder=self.marshaller.deserialize_voice_state,
            window_size=window_size,
        )

    def iter_voice_states_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.VOICE_STATE,
            self.marshaller.deserialize_voice_state,
            window_size=window_size,
        )

    async def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        if voice_state.channel_id is None:
            raise ValueError(&#34;Cannot set a voice state which isn&#39;t bound to a channel&#34;)

        data = self.marshaller.serialize_voice_state(voice_state)
        # We have to ensure this is deleted first to make sure previous references are removed.
        await self.delete_voice_state(voice_state.guild_id, voice_state.user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        await client.hset(int(voice_state.guild_id), int(voice_state.user_id), data)
        await self._add_ids(
            ResourceIndex.CHANNEL,
            voice_state.channel_id,
            ResourceIndex.VOICE_STATE,
            int(voice_state.user_id),
            redis_iterators.HashReferenceIterator.hash_key(voice_state.guild_id),
        )
        await self._optionally_set_user(voice_state.member.user)


class RedisCache(
    GuildCache,
    EmojiCache,
    GuildChannelCache,
    IntegrationCache,
    InviteCache,
    MemberCache,
    MessageCache,
    PresenceCache,
    RoleCache,
    UserCache,
    VoiceStateCache,
    traits.Cache,
):
    &#34;&#34;&#34;A Redis implementation of all the defined cache resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sake.redis.EmojiCache"><code class="flex name class">
<span>class <span class="ident">EmojiCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmojiCache(_Reference, traits.RefEmojiCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.EMOJI,)

    async def __bulk_add_emojis(
        self, emojis: typing.Iterable[emojis_.KnownCustomEmoji], guild_id: snowflakes.Snowflake
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.EMOJI)
        windows = redis_iterators.chunk_values(emojis)
        setters = (
            client.mset({int(emoji.id): self.marshaller.serialize_emoji(emoji) for emoji in window})
            for window in windows
        )
        user_setter = self._optionally_bulk_set_users(emoji.user for emoji in emojis if emoji.user is not None)
        reference_setter = self._add_ids(
            ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, *(int(emoji.id) for emoji in emojis)
        )
        asyncio.gather(*setters, user_setter, reference_setter)

    async def __on_emojis_update(self, event: guild_events.EmojisUpdateEvent) -&gt; None:
        await self.clear_emojis_for_guild(event.guild_id)

        if event.emojis:
            await self.__bulk_add_emojis(event.emojis, event.guild_id)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_emojis_for_guild(event.guild_id)
        if isinstance(event, (guild_events.GuildAvailableEvent, guild_events.GuildUpdateEvent)) and event.emojis:
            await self.__bulk_add_emojis(event.emojis.values(), event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.EmojisUpdateEvent, self.__on_emojis_update)
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            #  TODO: can we also listen for member delete to manage this?

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.EmojisUpdateEvent, self.__on_emojis_update)
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            #  TODO: can we also listen for member delete to manage this?

    async def clear_emojis(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.EMOJI)
        client = await self.get_connection(ResourceIndex.EMOJI)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(emoji_ids))))

    async def clear_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, cast=bytes)
        if not emoji_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, *emoji_ids)
        client = await self.get_connection(ResourceIndex.EMOJI)
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(emoji_ids)))

    async def delete_emoji(
        self, emoji_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_id = int(emoji_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_emoji(emoji_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.EMOJI)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI, emoji_id)
        await client.delete(emoji_id)

    async def get_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; emojis_.KnownCustomEmoji:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        emoji_id = int(emoji_id)
        client = await self.get_connection(ResourceIndex.EMOJI)
        data = await client.get(emoji_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Emoji entry `{emoji_id}` not found&#34;)

        return self.marshaller.deserialize_emoji(data)

    def iter_emojis(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[emojis_.KnownCustomEmoji]:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.EMOJI, self.marshaller.deserialize_emoji, window_size=window_size
        )

    def iter_emojis_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[emojis_.KnownCustomEmoji]:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.EMOJI)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.EMOJI, self.marshaller.deserialize_emoji, window_size=window_size
        )

    async def set_emoji(self, emoji: emojis_.KnownCustomEmoji, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.EmojiCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.EMOJI)
        data = self.marshaller.serialize_emoji(emoji)
        await self._add_ids(ResourceIndex.GUILD, emoji.guild_id, ResourceIndex.EMOJI, int(emoji.id))
        await client.set(int(emoji.id), data)

        if emoji.user is not None:
            await self._optionally_set_user(emoji.user)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.RefEmojiCache" href="traits.html#sake.traits.RefEmojiCache">RefEmojiCache</a></li>
<li><a title="sake.traits.EmojiCache" href="traits.html#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefEmojiCache" href="traits.html#sake.traits.RefEmojiCache">RefEmojiCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefEmojiCache.clear_emojis" href="traits.html#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.clear_emojis_for_guild" href="traits.html#sake.traits.RefEmojiCache.clear_emojis_for_guild">clear_emojis_for_guild</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.delete_emoji" href="traits.html#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.get_emoji" href="traits.html#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.iter_emojis" href="traits.html#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.iter_emojis_for_guild" href="traits.html#sake.traits.RefEmojiCache.iter_emojis_for_guild">iter_emojis_for_guild</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.set_emoji" href="traits.html#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.GuildCache"><code class="flex name class">
<span>class <span class="ident">GuildCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuildCache(ResourceClient, traits.GuildCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.GUILD,)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        client = await self.get_connection(ResourceIndex.GUILD)
        if isinstance(event, guild_events.GuildAvailableEvent):
            data = self.marshaller.serialize_guild(event.guild)
            await client.set(int(event.guild_id), data)

        elif isinstance(event, guild_events.GuildLeaveEvent):
            await client.delete(int(event.guild_id))

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    async def clear_guilds(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        await client.flushdb()

    async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        await client.delete(int(guild_id))

    async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        guild_id = int(guild_id)
        client = await self.get_connection(ResourceIndex.GUILD)
        data = await client.get(guild_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Guild entry `{guild_id}` not found&#34;)

        return self.marshaller.deserialize_guild(data)

    def iter_guilds(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.GatewayGuild]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.GUILD, self.marshaller.deserialize_guild, window_size=window_size
        )

    async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.GUILD)
        data = self.marshaller.serialize_guild(guild)
        await client.set(int(guild.id), data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.GuildCache" href="traits.html#sake.traits.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.GuildCache" href="traits.html#sake.traits.GuildCache">GuildCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.GuildCache.clear_guilds" href="traits.html#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.delete_guild" href="traits.html#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.get_guild" href="traits.html#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.iter_guilds" href="traits.html#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.set_guild" href="traits.html#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.GuildChannelCache"><code class="flex name class">
<span>class <span class="ident">GuildChannelCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuildChannelCache(_Reference, traits.RefGuildChannelCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.CHANNEL,)

    async def __on_guild_channel_event(self, event: channel_events.GuildChannelEvent) -&gt; None:
        if isinstance(event, (channel_events.GuildChannelCreateEvent, channel_events.GuildChannelUpdateEvent)):
            await self.set_guild_channel(event.channel)

        elif isinstance(event, channel_events.GuildChannelDeleteEvent):
            await self.delete_guild_channel(event.channel_id, guild_id=event.guild_id)

        elif isinstance(event, channel_events.GuildPinsUpdateEvent):
            try:
                channel = await self.get_guild_channel(event.channel_id)
            except errors.EntryNotFound:
                pass
            else:
                assert isinstance(
                    channel, (channels.GuildNewsChannel, channels.GuildTextChannel)
                ), &#34;unexpected channel type for a pin update&#34;
                channel.last_pin_timestamp = event.last_pin_timestamp
                await self.set_guild_channel(channel)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_guild_channels_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.channels:
            client = await self.get_connection(ResourceIndex.CHANNEL)
            windows = redis_iterators.chunk_values(event.channels.items())
            setters = (
                client.mset(_cast_map_window(window, int, self.marshaller.serialize_guild_channel))
                for window in windows
            )
            id_setter = self._add_ids(
                ResourceIndex.GUILD, event.guild_id, ResourceIndex.CHANNEL, *map(int, event.channels.keys())
            )
            asyncio.gather(*setters, id_setter)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(channel_events.GuildChannelEvent, self.__on_guild_channel_event)
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(channel_events.GuildChannelEvent, self.__on_guild_channel_event)
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)

    async def clear_guild_channels(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.CHANNEL)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(channel_ids))))

    async def clear_guild_channels_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        guild_id = int(guild_id)
        channel_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, cast=bytes)
        if not channel_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, *channel_ids)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        #  TODO: is there any benefit to chunking on bulk delete?
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(channel_ids)))

    async def delete_guild_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_id = int(channel_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_guild_channel(channel_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.CHANNEL)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL, channel_id)
        await client.delete(channel_id)

    async def get_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; channels.GuildChannel:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        channel_id = int(channel_id)
        client = await self.get_connection(ResourceIndex.CHANNEL)
        data = await client.get(channel_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Guild channel entry `{channel_id}` not found&#34;)

        return self.marshaller.deserialize_guild_channel(data)

    def iter_guild_channels(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[channels.GuildChannel]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.CHANNEL, self.marshaller.deserialize_guild_channel, window_size=window_size
        )

    def iter_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[channels.GuildChannel]:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.CHANNEL)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.CHANNEL, self.marshaller.deserialize_guild_channel, window_size=window_size
        )

    async def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.GuildChannelCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.CHANNEL)
        data = self.marshaller.serialize_guild_channel(channel)
        await client.set(int(channel.id), data)
        await self._add_ids(ResourceIndex.GUILD, int(channel.guild_id), ResourceIndex.CHANNEL, int(channel.id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.RefGuildChannelCache" href="traits.html#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></li>
<li><a title="sake.traits.GuildChannelCache" href="traits.html#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefGuildChannelCache" href="traits.html#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefGuildChannelCache.clear_guild_channels" href="traits.html#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild" href="traits.html#sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.delete_guild_channel" href="traits.html#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.get_guild_channel" href="traits.html#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.iter_guild_channels" href="traits.html#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild" href="traits.html#sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild">iter_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.set_guild_channel" href="traits.html#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.IntegrationCache"><code class="flex name class">
<span>class <span class="ident">IntegrationCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntegrationCache(_Reference, traits.IntegrationCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.INTEGRATION,)

    async def __on_guild_leave_event(self, event: guild_events.GuildLeaveEvent) -&gt; None:
        await self.clear_integrations_for_guild(event.guild_id)

    async def __on_integration_event(self, event: guild_events.IntegrationEvent) -&gt; None:
        if isinstance(event, (guild_events.IntegrationCreateEvent, guild_events.IntegrationUpdateEvent)):
            await self.set_integration(event.integration)

        elif isinstance(event, guild_events.IntegrationDeleteEvent):
            await self.delete_integration(event.id, guild_id=event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildLeaveEvent, self.__on_guild_leave_event)
            self.dispatch.dispatcher.subscribe(guild_events.IntegrationEvent, self.__on_integration_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildLeaveEvent, self.__on_guild_leave_event)
            self.dispatch.dispatcher.unsubscribe(guild_events.IntegrationEvent, self.__on_integration_event)

    async def clear_integrations(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        ids = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.INTEGRATION)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids)))

    async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        guild_id = int(guild_id)
        ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, cast=bytes)
        if not ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, *ids)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids)))

    async def delete_integration(
        self, integration_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        integration_id = int(integration_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_integration(integration_id)).guild_id
            except errors.EntryNotFound:
                return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, integration_id)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        await client.delete(integration_id)

    async def get_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; guilds.Integration:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        data = await client.get(int(integration_id))

        if not data:
            raise errors.EntryNotFound(f&#34;Integration entry `{integration_id}` not found&#34;)

        return self.marshaller.deserialize_integration(data)

    def iter_integrations(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Integration]:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.INTEGRATION, builder=self.marshaller.deserialize_integration, window_size=window_size
        )

    def iter_integrations_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Integration]:
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION).encode()
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.INTEGRATION, self.marshaller.deserialize_integration, window_size=window_size
        )

    async def set_integration(self, integration: guilds.Integration, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.IntegrationCache&gt;&gt;
        data = self.marshaller.serialize_integration(integration)
        client = await self.get_connection(ResourceIndex.INTEGRATION)
        await client.set(int(integration.id), data)
        await self._add_ids(ResourceIndex.GUILD, integration.guild_id, ResourceIndex.INTEGRATION, int(integration.id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.IntegrationCache" href="traits.html#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.IntegrationCache.clear_integrations_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_integrations_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    guild_id = int(guild_id)
    ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, cast=bytes)
    if not ids:
        return

    await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION, *ids)
    client = await self.get_connection(ResourceIndex.INTEGRATION)
    asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids)))</code></pre>
</details>
</dd>
<dt id="sake.redis.IntegrationCache.iter_integrations_for_guild"><code class="name flex">
<span>def <span class="ident">iter_integrations_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Integration]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_integrations_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[guilds.Integration]:
    key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.INTEGRATION).encode()
    return redis_iterators.ReferenceIterator(
        self, key, ResourceIndex.INTEGRATION, self.marshaller.deserialize_integration, window_size=window_size
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.IntegrationCache" href="traits.html#sake.traits.IntegrationCache">IntegrationCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.IntegrationCache.clear_integrations" href="traits.html#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.delete_integration" href="traits.html#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.get_integration" href="traits.html#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.iter_integrations" href="traits.html#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.set_integration" href="traits.html#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.InviteCache"><code class="flex name class">
<span>class <span class="ident">InviteCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InviteCache(ResourceClient, traits.InviteCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.INVITE,)

    async def __on_invite_event(self, event: channel_events.InviteEvent) -&gt; None:
        if isinstance(event, channel_events.InviteCreateEvent):
            await self.set_invite(event.invite)

        elif isinstance(event, channel_events.InviteDeleteEvent):
            await self.delete_invite(event.code)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(channel_events.InviteEvent, self.__on_invite_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(channel_events.InviteEvent, self.__on_invite_event)

    def with_invite_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for invite entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for invites in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_invite&#34;] = _convert_expire_time(expire)

        elif &#34;expire_invite&#34; in self.metadata:
            del self.metadata[&#34;expire_invite&#34;]

        return self

    async def clear_invites(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        await client.flushdb()

    async def delete_invite(self, invite_code: str, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        await client.delete(str(invite_code))

    async def get_invite(self, invite_code: str, /) -&gt; invites_.InviteWithMetadata:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        invite_code = str(invite_code)
        client = await self.get_connection(ResourceIndex.INVITE)
        data = await client.get(invite_code)
        if not data:
            raise errors.EntryNotFound(f&#34;Invite entry `{invite_code}` not found&#34;)

        return self.marshaller.deserialize_invite(data)

    def iter_invites(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[invites_.InviteWithMetadata]:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.INVITE, self.marshaller.deserialize_invite, window_size=window_size
        )

    async def set_invite(
        self, invite: invites_.InviteWithMetadata, /, *, expire_time: typing.Optional[ExpireT] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.InviteCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        data = self.marshaller.serialize_invite(invite)

        if expire_time is None and invite.expires_at is not None:
            expire_time = round((invite.expires_at - time.utc_datetime()).total_seconds() * 1000)

            # If this invite has already expired or the system clock is direly out of sync then we cannot
            # use the expire time we just calculated.
            if expire_time &lt;= 0:
                expire_time = None

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_invite&#34;, DEFAULT_INVITE_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        # Aioredis treats keys and values as type invariant so we want to ensure this is a str and not a class which
        # subclasses str.
        await client.set(str(invite.code), data, pexpire=expire_time)

        if invite.target_user is not None:
            await self._optionally_set_user(invite.target_user)

        if invite.inviter is not None:
            await self._optionally_set_user(invite.inviter)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.InviteCache" href="traits.html#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.InviteCache.with_invite_expire"><code class="name flex">
<span>def <span class="ident">with_invite_expire</span></span>(<span>self: ResourceT, expire: typing.Optional[ExpireT], /) ‑> ~ResourceT</span>
</code></dt>
<dd>
<div class="desc"><p>Set the default expire time for invite entries added with this client.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expire</code></strong> :&ensp;<code>typing.Union[datetime.timedelta, builtins.int, builtins.float]</code></dt>
<dd>The default expire time to add for invites in this cache or <code>builtins.None</code>
to set back to the default behaviour.
This may either be the number of seconds as an int or float (where
millisecond precision is supported) or a timedelta.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ResourceT</code></dt>
<dd>The client this is being called on to enable chained calls.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_invite_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
    &#34;&#34;&#34;Set the default expire time for invite entries added with this client.

    Parameters
    ----------
    expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
        The default expire time to add for invites in this cache or `builtins.None`
        to set back to the default behaviour.
        This may either be the number of seconds as an int or float (where
        millisecond precision is supported) or a timedelta.

    Returns
    -------
    ResourceT
        The client this is being called on to enable chained calls.
    &#34;&#34;&#34;
    if expire is not None:
        self.metadata[&#34;expire_invite&#34;] = _convert_expire_time(expire)

    elif &#34;expire_invite&#34; in self.metadata:
        del self.metadata[&#34;expire_invite&#34;]

    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.InviteCache" href="traits.html#sake.traits.InviteCache">InviteCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.InviteCache.clear_invites" href="traits.html#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.delete_invite" href="traits.html#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.get_invite" href="traits.html#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.iter_invites" href="traits.html#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.set_invite" href="traits.html#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.MemberCache"><code class="flex name class">
<span>class <span class="ident">MemberCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemberCache(ResourceClient, traits.MemberCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.MEMBER,)

    async def __bulk_add_members(
        self, guild_id: snowflakes.Snowflakeish, members: typing.Mapping[snowflakes.Snowflake, guilds.Member]
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.MEMBER)
        windows = redis_iterators.chunk_values(members.items())
        setters = (
            client.hmset_dict(int(guild_id), _cast_map_window(window, int, self.marshaller.serialize_member))
            for window in windows
        )
        user_setter = self._optionally_bulk_set_users(member.user for member in members.values())
        asyncio.gather(*setters, user_setter)

    async def __on_guild_availability(self, event: guild_events.GuildAvailableEvent) -&gt; None:
        await self.clear_members_for_guild(event.guild_id)
        if event.members:
            await self.__bulk_add_members(event.guild_id, event.members)

    async def __on_member_event(self, event: member_events.MemberEvent) -&gt; None:
        if isinstance(event, (member_events.MemberCreateEvent, member_events.MemberUpdateEvent)):
            await self.set_member(event.member)

        elif isinstance(event, member_events.MemberDeleteEvent):
            back_off = backoff.Backoff()
            async for _ in back_off:
                if &#34;own_id&#34; in self.metadata:
                    break

                try:
                    user = await self.rest.rest.fetch_my_user()

                except hikari_errors.RateLimitedError as exc:
                    back_off.set_next_backoff(exc.retry_after)

                except hikari_errors.InternalServerError:
                    pass

                else:
                    self.metadata[&#34;own_id&#34;] = user.id
                    break

            own_id = snowflakes.Snowflake(self.metadata[&#34;own_id&#34;])
            if event.user_id == own_id:
                await self.clear_members_for_guild(event.guild_id)
            else:
                await self.delete_member(event.guild_id, event.user_id)

    async def __on_member_chunk_event(self, event: shard_events.MemberChunkEvent) -&gt; None:
        await self.__bulk_add_members(event.guild_id, event.members)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildAvailableEvent, self.__on_guild_availability)
            self.dispatch.dispatcher.subscribe(member_events.MemberEvent, self.__on_member_event)
            self.dispatch.dispatcher.subscribe(shard_events.MemberChunkEvent, self.__on_member_chunk_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildAvailableEvent, self.__on_guild_availability)
            self.dispatch.dispatcher.unsubscribe(member_events.MemberEvent, self.__on_member_event)
            self.dispatch.dispatcher.unsubscribe(shard_events.MemberChunkEvent, self.__on_member_chunk_event)

    async def clear_members(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.flushdb()

    async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.delete(int(guild_id))

    async def delete_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        await client.hdel(int(guild_id), int(user_id))

    async def get_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; guilds.Member:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        guild_id = int(guild_id)
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.MEMBER)
        data = await client.hget(guild_id, user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Member entry `{user_id}` not found for guild `{guild_id}`&#34;)

        return self.marshaller.deserialize_member(data)

    def iter_members(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Member]:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.MEMBER, self.marshaller.deserialize_member, window_size=window_size
        )

    def iter_members_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Member]:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.MEMBER,
            self.marshaller.deserialize_member,
            window_size=window_size,
        )

    async def set_member(self, member: guilds.Member, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MEMBER)
        data = self.marshaller.serialize_member(member)
        await client.hset(int(member.guild_id), int(member.user.id), data)
        await self._optionally_set_user(member.user)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.MemberCache" href="traits.html#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.MemberCache.clear_members_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_members_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
    client = await self.get_connection(ResourceIndex.MEMBER)
    await client.delete(int(guild_id))</code></pre>
</details>
</dd>
<dt id="sake.redis.MemberCache.iter_members_for_guild"><code class="name flex">
<span>def <span class="ident">iter_members_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Member]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_members_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[guilds.Member]:
    # &lt;&lt;Inherited docstring from sake.traits.MemberCache&gt;&gt;
    return redis_iterators.SpecificMapIterator(
        self,
        int(guild_id),
        ResourceIndex.MEMBER,
        self.marshaller.deserialize_member,
        window_size=window_size,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MemberCache" href="traits.html#sake.traits.MemberCache">MemberCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MemberCache.clear_members" href="traits.html#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.delete_member" href="traits.html#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.get_member" href="traits.html#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.iter_members" href="traits.html#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.set_member" href="traits.html#sake.traits.MemberCache.set_member">set_member</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.MessageCache"><code class="flex name class">
<span>class <span class="ident">MessageCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageCache(ResourceClient, traits.MessageCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.MESSAGE,)

    async def __on_message_event(self, event: message_events.MessageEvent) -&gt; None:
        if isinstance(event, message_events.MessageCreateEvent):
            await self.set_message(event.message)

        elif isinstance(event, message_events.MessageUpdateEvent):
            await self.update_message(event.message)

        elif isinstance(event, message_events.MessageDeleteEvent):
            client = await self.get_connection(ResourceIndex.MESSAGE)
            asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(map(int, event.message_ids))))

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(message_events.MessageEvent, self.__on_message_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(message_events.MessageEvent, self.__on_message_event)

    def with_message_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for message entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for messages in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_message&#34;] = _convert_expire_time(expire)

        elif &#34;expire_message&#34; in self.metadata:
            del self.metadata[&#34;expire_message&#34;]

        return self

    async def clear_messages(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.INVITE)
        await client.flushdb()

    async def delete_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.MESSAGE)
        await client.delete(int(message_id))

    async def get_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; messages.Message:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        message_id = int(message_id)
        client = await self.get_connection(ResourceIndex.MESSAGE)
        data = await client.get(message_id)
        if not data:
            raise errors.EntryNotFound(f&#34;Message entry `{message_id}` not found&#34;)

        return self.marshaller.deserialize_message(data)

    def iter_messages(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[messages.Message]:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.MESSAGE, self.marshaller.deserialize_message, window_size=window_size
        )

    async def set_message(self, message: messages.Message, /, *, expire_time: typing.Optional[ExpireT] = None) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        data = await self.marshaller.serialize_message(message)
        client = await self.get_connection(ResourceIndex.MESSAGE)

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_message&#34;, DEFAULT_FAST_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        await client.set(int(message.id), data, expire=expire_time)
        await self._optionally_set_user(message.author)

    async def update_message(self, message: messages.PartialMessage, /) -&gt; bool:
        # &lt;&lt;Inherited docstring from sake.traits.MessageCache&gt;&gt;
        # This is a special case method for handling the partial message updates we get
        try:
            full_message = await self.get_message(message.id)
        except errors.EntryNotFound:
            return False

        if message.content is not undefined.UNDEFINED:
            full_message.content = message.content

        if message.timestamp is not undefined.UNDEFINED:
            full_message.timestamp = message.timestamp

        if message.edited_timestamp is not undefined.UNDEFINED:
            full_message.edited_timestamp = message.edited_timestamp

        if message.is_tts is not undefined.UNDEFINED:
            full_message.is_tts = message.is_tts

        if message.is_mentioning_everyone is not undefined.UNDEFINED:
            full_message.is_mentioning_everyone = message.is_mentioning_everyone

        if message.user_mentions is not undefined.UNDEFINED:
            full_message.user_mentions = message.user_mentions

        if message.role_mentions is not undefined.UNDEFINED:
            full_message.role_mentions = message.role_mentions

        if message.channel_mentions is not undefined.UNDEFINED:
            full_message.channel_mentions = message.channel_mentions

        if message.attachments is not undefined.UNDEFINED:
            full_message.attachments = message.attachments

        if message.embeds is not undefined.UNDEFINED:
            full_message.embeds = message.embeds

        if message.reactions is not undefined.UNDEFINED:
            full_message.reactions = message.reactions

        if message.is_pinned is not undefined.UNDEFINED:
            full_message.is_pinned = message.is_pinned

        if message.webhook_id is not undefined.UNDEFINED:
            full_message.webhook_id = message.webhook_id

        if message.type is not undefined.UNDEFINED:
            full_message.type = message.type

        if message.activity is not undefined.UNDEFINED:
            full_message.activity = message.activity

        if message.application is not undefined.UNDEFINED:
            full_message.application = message.application

        if message.message_reference is not undefined.UNDEFINED:
            full_message.message_reference = message.message_reference

        if message.flags is not undefined.UNDEFINED:
            full_message.flags = message.flags

        if message.nonce is not undefined.UNDEFINED:
            full_message.nonce = message.nonce

        await self.set_message(full_message)
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.MessageCache" href="traits.html#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.MessageCache.with_message_expire"><code class="name flex">
<span>def <span class="ident">with_message_expire</span></span>(<span>self: ResourceT, expire: typing.Optional[ExpireT], /) ‑> ~ResourceT</span>
</code></dt>
<dd>
<div class="desc"><p>Set the default expire time for message entries added with this client.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expire</code></strong> :&ensp;<code>typing.Union[datetime.timedelta, builtins.int, builtins.float]</code></dt>
<dd>The default expire time to add for messages in this cache or <code>builtins.None</code>
to set back to the default behaviour.
This may either be the number of seconds as an int or float (where
millisecond precision is supported) or a timedelta.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ResourceT</code></dt>
<dd>The client this is being called on to enable chained calls.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_message_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
    &#34;&#34;&#34;Set the default expire time for message entries added with this client.

    Parameters
    ----------
    expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
        The default expire time to add for messages in this cache or `builtins.None`
        to set back to the default behaviour.
        This may either be the number of seconds as an int or float (where
        millisecond precision is supported) or a timedelta.

    Returns
    -------
    ResourceT
        The client this is being called on to enable chained calls.
    &#34;&#34;&#34;
    if expire is not None:
        self.metadata[&#34;expire_message&#34;] = _convert_expire_time(expire)

    elif &#34;expire_message&#34; in self.metadata:
        del self.metadata[&#34;expire_message&#34;]

    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MessageCache" href="traits.html#sake.traits.MessageCache">MessageCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MessageCache.clear_messages" href="traits.html#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.delete_message" href="traits.html#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.get_message" href="traits.html#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.iter_messages" href="traits.html#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.set_message" href="traits.html#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.update_message" href="traits.html#sake.traits.MessageCache.update_message">update_message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.PresenceCache"><code class="flex name class">
<span>class <span class="ident">PresenceCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PresenceCache(ResourceClient, traits.PresenceCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.PRESENCE,)

    async def __bulk_add_presences(
        self, guild_id: snowflakes.Snowflake, presences: typing.Mapping[snowflakes.Snowflake, presences_.MemberPresence]
    ) -&gt; None:
        client = await self.get_connection(ResourceIndex.PRESENCE)
        windows = redis_iterators.chunk_values(presences.items())
        setters = (
            client.hmset_dict(int(guild_id), _cast_map_window(window, int, self.marshaller.serialize_presence))
            for window in windows
        )
        asyncio.gather(*setters)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_presences_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.presences:
            await self.__bulk_add_presences(event.guild_id, event.presences)

    async def __on_member_chunk(self, event: shard_events.MemberChunkEvent) -&gt; None:
        await self.__bulk_add_presences(event.guild_id, event.presences)

    async def __on_presence_update_event(self, event: guild_events.PresenceUpdateEvent) -&gt; None:
        if event.presence.visible_status is presences_.Status.OFFLINE:
            await self.delete_presence(event.guild_id, event.user_id)
            # TODO: handle presence.user?

        else:
            await self.set_presence(event.presence)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(shard_events.MemberChunkEvent, self.__on_member_chunk)
            self.dispatch.dispatcher.subscribe(guild_events.PresenceUpdateEvent, self.__on_presence_update_event)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(shard_events.MemberChunkEvent, self.__on_member_chunk)
            self.dispatch.dispatcher.unsubscribe(guild_events.PresenceUpdateEvent, self.__on_presence_update_event)

    async def clear_presences(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.flushdb()

    async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.delete(int(guild_id))

    async def delete_presence(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.hdel(int(guild_id), int(user_id))

    async def get_presence(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; presences_.MemberPresence:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.PRESENCE)
        data = await client.hget(int(guild_id), int(user_id))
        return self.marshaller.deserialize_presence(data)

    def iter_presences(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[presences_.MemberPresence]:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.PRESENCE, self.marshaller.deserialize_presence, window_size=window_size
        )

    def iter_presences_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[presences_.MemberPresence]:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.PRESENCE,
            self.marshaller.deserialize_presence,
            window_size=window_size,
        )

    async def set_presence(self, presence: presences_.MemberPresence, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
        data = self.marshaller.serialize_presence(presence)
        client = await self.get_connection(ResourceIndex.PRESENCE)
        await client.hset(int(presence.guild_id), int(presence.user_id), data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.PresenceCache" href="traits.html#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.PresenceCache.clear_presences_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_presences_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
    client = await self.get_connection(ResourceIndex.PRESENCE)
    await client.delete(int(guild_id))</code></pre>
</details>
</dd>
<dt id="sake.redis.PresenceCache.iter_presences_for_guild"><code class="name flex">
<span>def <span class="ident">iter_presences_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.presences.MemberPresence]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_presences_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[presences_.MemberPresence]:
    # &lt;&lt;Inherited docstring from sake.traits.PresenceCache&gt;&gt;
    return redis_iterators.SpecificMapIterator(
        self,
        int(guild_id),
        ResourceIndex.PRESENCE,
        self.marshaller.deserialize_presence,
        window_size=window_size,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.PresenceCache" href="traits.html#sake.traits.PresenceCache">PresenceCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.PresenceCache.clear_presences" href="traits.html#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.delete_presence" href="traits.html#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.get_presence" href="traits.html#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.iter_presences" href="traits.html#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.set_presence" href="traits.html#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.RedisCache"><code class="flex name class">
<span>class <span class="ident">RedisCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Redis implementation of all the defined cache resources.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RedisCache(
    GuildCache,
    EmojiCache,
    GuildChannelCache,
    IntegrationCache,
    InviteCache,
    MemberCache,
    MessageCache,
    PresenceCache,
    RoleCache,
    UserCache,
    VoiceStateCache,
    traits.Cache,
):
    &#34;&#34;&#34;A Redis implementation of all the defined cache resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.redis.GuildCache" href="#sake.redis.GuildCache">GuildCache</a></li>
<li><a title="sake.redis.EmojiCache" href="#sake.redis.EmojiCache">EmojiCache</a></li>
<li><a title="sake.redis.GuildChannelCache" href="#sake.redis.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.redis.IntegrationCache" href="#sake.redis.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.redis.InviteCache" href="#sake.redis.InviteCache">InviteCache</a></li>
<li><a title="sake.redis.MemberCache" href="#sake.redis.MemberCache">MemberCache</a></li>
<li><a title="sake.redis.MessageCache" href="#sake.redis.MessageCache">MessageCache</a></li>
<li><a title="sake.redis.PresenceCache" href="#sake.redis.PresenceCache">PresenceCache</a></li>
<li><a title="sake.redis.RoleCache" href="#sake.redis.RoleCache">RoleCache</a></li>
<li><a title="sake.redis.UserCache" href="#sake.redis.UserCache">UserCache</a></li>
<li>sake.redis._MeCache</li>
<li><a title="sake.redis.VoiceStateCache" href="#sake.redis.VoiceStateCache">VoiceStateCache</a></li>
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.RefEmojiCache" href="traits.html#sake.traits.RefEmojiCache">RefEmojiCache</a></li>
<li><a title="sake.traits.RefGuildChannelCache" href="traits.html#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></li>
<li><a title="sake.traits.Cache" href="traits.html#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.GuildCache" href="traits.html#sake.traits.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.EmojiCache" href="traits.html#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.GuildChannelCache" href="traits.html#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.IntegrationCache" href="traits.html#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.InviteCache" href="traits.html#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.MeCache" href="traits.html#sake.traits.MeCache">MeCache</a></li>
<li><a title="sake.traits.MemberCache" href="traits.html#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.MessageCache" href="traits.html#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.PresenceCache" href="traits.html#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.RoleCache" href="traits.html#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.UserCache" href="traits.html#sake.traits.UserCache">UserCache</a></li>
<li><a title="sake.traits.VoiceStateCache" href="traits.html#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.GuildCache" href="#sake.redis.GuildCache">GuildCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.GuildCache.clear_guilds" href="traits.html#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.redis.GuildCache.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.GuildCache.delete_guild" href="traits.html#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.redis.GuildCache.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.GuildCache.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.GuildCache.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.GuildCache.get_guild" href="traits.html#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.redis.GuildCache.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.GuildCache.iter_guilds" href="traits.html#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.redis.GuildCache.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.GuildCache.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
<li><code><a title="sake.redis.GuildCache.set_guild" href="traits.html#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
<li><code><a title="sake.redis.GuildCache.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.GuildCache.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.EmojiCache" href="#sake.redis.EmojiCache">EmojiCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.EmojiCache.clear_emojis" href="traits.html#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.redis.EmojiCache.clear_emojis_for_guild" href="traits.html#sake.traits.RefEmojiCache.clear_emojis_for_guild">clear_emojis_for_guild</a></code></li>
<li><code><a title="sake.redis.EmojiCache.delete_emoji" href="traits.html#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.redis.EmojiCache.get_emoji" href="traits.html#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.redis.EmojiCache.iter_emojis" href="traits.html#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.redis.EmojiCache.iter_emojis_for_guild" href="traits.html#sake.traits.RefEmojiCache.iter_emojis_for_guild">iter_emojis_for_guild</a></code></li>
<li><code><a title="sake.redis.EmojiCache.set_emoji" href="traits.html#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.GuildChannelCache" href="#sake.redis.GuildChannelCache">GuildChannelCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.GuildChannelCache.clear_guild_channels" href="traits.html#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.clear_guild_channels_for_guild" href="traits.html#sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.delete_guild_channel" href="traits.html#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.get_guild_channel" href="traits.html#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.iter_guild_channels" href="traits.html#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.iter_guild_channels_for_guild" href="traits.html#sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild">iter_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.redis.GuildChannelCache.set_guild_channel" href="traits.html#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.IntegrationCache" href="#sake.redis.IntegrationCache">IntegrationCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.IntegrationCache.clear_integrations" href="traits.html#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.redis.IntegrationCache.delete_integration" href="traits.html#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.redis.IntegrationCache.get_integration" href="traits.html#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.redis.IntegrationCache.iter_integrations" href="traits.html#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.redis.IntegrationCache.set_integration" href="traits.html#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.InviteCache" href="#sake.redis.InviteCache">InviteCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.InviteCache.clear_invites" href="traits.html#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.redis.InviteCache.delete_invite" href="traits.html#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.redis.InviteCache.get_invite" href="traits.html#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.redis.InviteCache.iter_invites" href="traits.html#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.redis.InviteCache.set_invite" href="traits.html#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
<li><code><a title="sake.redis.InviteCache.with_invite_expire" href="#sake.redis.InviteCache.with_invite_expire">with_invite_expire</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.MemberCache" href="#sake.redis.MemberCache">MemberCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.MemberCache.clear_members" href="traits.html#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.redis.MemberCache.delete_member" href="traits.html#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.redis.MemberCache.get_member" href="traits.html#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.redis.MemberCache.iter_members" href="traits.html#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.redis.MemberCache.set_member" href="traits.html#sake.traits.MemberCache.set_member">set_member</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.MessageCache" href="#sake.redis.MessageCache">MessageCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.MessageCache.clear_messages" href="traits.html#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.redis.MessageCache.delete_message" href="traits.html#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.redis.MessageCache.get_message" href="traits.html#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.redis.MessageCache.iter_messages" href="traits.html#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.redis.MessageCache.set_message" href="traits.html#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.redis.MessageCache.update_message" href="traits.html#sake.traits.MessageCache.update_message">update_message</a></code></li>
<li><code><a title="sake.redis.MessageCache.with_message_expire" href="#sake.redis.MessageCache.with_message_expire">with_message_expire</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.PresenceCache" href="#sake.redis.PresenceCache">PresenceCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.PresenceCache.clear_presences" href="traits.html#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.redis.PresenceCache.delete_presence" href="traits.html#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.redis.PresenceCache.get_presence" href="traits.html#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.redis.PresenceCache.iter_presences" href="traits.html#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.redis.PresenceCache.set_presence" href="traits.html#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.RoleCache" href="#sake.redis.RoleCache">RoleCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.RoleCache.clear_roles" href="traits.html#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.redis.RoleCache.delete_role" href="traits.html#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.redis.RoleCache.get_role" href="traits.html#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.redis.RoleCache.iter_roles" href="traits.html#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.redis.RoleCache.set_role" href="traits.html#sake.traits.RoleCache.set_role">set_role</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.UserCache" href="#sake.redis.UserCache">UserCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.UserCache.clear_users" href="traits.html#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.redis.UserCache.delete_me" href="traits.html#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.redis.UserCache.delete_user" href="traits.html#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.redis.UserCache.get_me" href="traits.html#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.redis.UserCache.get_user" href="traits.html#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.redis.UserCache.iter_users" href="traits.html#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.redis.UserCache.set_me" href="traits.html#sake.traits.MeCache.set_me">set_me</a></code></li>
<li><code><a title="sake.redis.UserCache.set_user" href="traits.html#sake.traits.UserCache.set_user">set_user</a></code></li>
<li><code><a title="sake.redis.UserCache.with_user_expire" href="#sake.redis.UserCache.with_user_expire">with_user_expire</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.VoiceStateCache" href="#sake.redis.VoiceStateCache">VoiceStateCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.VoiceStateCache.clear_voice_states" href="traits.html#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.delete_voice_state" href="traits.html#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.get_voice_state" href="traits.html#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.iter_voice_states" href="traits.html#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.set_voice_state" href="traits.html#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.ResourceClient"><code class="flex name class">
<span>class <span class="ident">ResourceClient</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResourceClient(traits.Resource, abc.ABC):
    &#34;&#34;&#34;A base client which all resources in this implementation will implement.

    !!! note
        This cannot be initialised by itself and is useless alone.

    Parameters
    ----------
    rest : hikari.traits.RESTAware
        The REST aware Hikari client to bind this resource client to.
    address : typing.Union[str, typing.Tuple[str, typing.Union[str, int]]
        The address to use to connect to the Redis backend server this
        resource is linked to. This may either be a string url in the form
        of `&#34;redis://localhost:4242&#34;` or a tuple of an address to a port
        in the form of `(&#34;localhost&#34;, 4242)`.

    Other Parameters
    ----------------
    dispatch : typing.Optional[hikari.traits.DispatchAware]
        The dispatcher aware Hikari client to bind this resource client to.
        This can be left as `builtins.None` to avoid this client from
        automatically registering any event listeners.
    password : typing.Optional[str]
        The password to optionally use to connect ot the backend Redis
        server.
    ssl : typing.Union[ssl.SSLContext, builtins.bool, builtins.None]
        The SSL context to use when connecting to the Redis backend server,
        this may be a context object, bool value or None to leave default
        behaviour (which will likely be no SSL).
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;__address&#34;,
        &#34;__clients&#34;,
        &#34;__marshaller&#34;,
        &#34;__dispatch&#34;,
        &#34;__metadata&#34;,
        &#34;__password&#34;,
        &#34;__rest&#34;,
        &#34;__ssl&#34;,
        &#34;__started&#34;,
    )

    def __init__(
        self,
        rest: hikari_traits.RESTAware,
        dispatch: typing.Optional[hikari_traits.DispatcherAware] = None,
        /,
        *,
        address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]],
        password: typing.Optional[str] = None,
        ssl: typing.Union[ssl_.SSLContext, bool, None] = None,
        metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,
        object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None,
    ) -&gt; None:
        self.__address = address
        self.__dispatch = dispatch
        self.__clients: typing.MutableMapping[ResourceIndex, aioredis.Redis] = {}
        self.__marshaller = object_marshaller or marshalling.JSONMarshaller(rest)
        self.__metadata = metadata or {}
        self.__password = password
        self.__rest = rest
        self.__ssl = ssl
        self.__started = False

    async def __aenter__(self: ResourceT) -&gt; ResourceT:
        await self.open()
        return self

    async def __aexit__(
        self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType
    ) -&gt; None:
        await self.close()

    def __enter__(self) -&gt; typing.NoReturn:
        # This is async only.
        cls = type(self)
        raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

    def __exit__(self, exc_type: typing.Type[Exception], exc_val: Exception, exc_tb: types.TracebackType) -&gt; None:
        return None

    @classmethod
    @abc.abstractmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        &#34;&#34;&#34;The index for the resource which this class is linked to.

        !!! note
            This should be called on specific base classes and will not be
            accurate after inheritance.

        Returns
        -------
        ResourceIndex
            The index of the resource this class is linked to.
        &#34;&#34;&#34;
        return ()

    @property  # As a note, this will only be set if this is actively hooked into event dispatchers
    def dispatch(self) -&gt; typing.Optional[hikari_traits.DispatcherAware]:
        &#34;&#34;&#34;The dispatcher aware client this resource client is tied to, if set.

        !!! note
            If this is set then event listeners will be (de)registered
            when this resource is opened/closed.

        Returns
        -------
        typing.Optional[hikari.traits.DispatcherAware]
            The dispatcher aware client this resource is tied to if set,
            else `builtins.None`.
        &#34;&#34;&#34;
        return self.__dispatch

    @property
    def marshaller(self) -&gt; marshalling.ObjectMarshaller[bytes]:
        return self.__marshaller

    @property
    def metadata(self) -&gt; typing.MutableMapping[str, typing.Any]:
        return self.__metadata

    @property  # unlike here where this is 100% required for building models.
    def rest(self) -&gt; hikari_traits.RESTAware:
        &#34;&#34;&#34;The REST aware client this resource client is tied to.

        This is used to build models with a `app` attribute.

        Returns
        -------
        hikari.traits.RESTAware
            The REST aware client this resource is tied to.
        &#34;&#34;&#34;
        return self.__rest

    async def get_connection(self, resource: ResourceIndex, /) -&gt; aioredis.Redis:
        &#34;&#34;&#34;Get the connection for a specific resource.

        Parameters
        ----------
        resource : ResourceIndex
            The index of the resource to get a connection for.

        Returns
        -------
        aioredis.Redis
            The connection instance for the specified resource.

        Raises
        ------
        TypeError
            When this method is called on a closed client.
        ValueError
            When you pass an invalid resource for the client.
        &#34;&#34;&#34;
        if not self.__started:
            raise TypeError(&#34;Cannot use an inactive client&#34;)

        try:
            return self.__clients[resource]
        except KeyError:
            raise ValueError(f&#34;Resource index `{resource}` is invalid for this client&#34;) from None

    @classmethod
    def _get_indexes(cls) -&gt; typing.MutableSet[ResourceIndex]:
        results: typing.Set[ResourceIndex] = set()
        for sub_class in cls.mro():
            if issubclass(sub_class, ResourceClient):
                results.update(sub_class.index())

        return results

    async def get_connection_status(self, resource: ResourceIndex, /) -&gt; bool:
        &#34;&#34;&#34;Get the status of the internal connection for a specific resource.

        Parameters
        ----------
        resource : ResourceIndex
            The index of the resource to get the status for.

        Returns
        -------
        bool
            Whether the client has an active connection for the specified resource.
        &#34;&#34;&#34;
        return resource in self.__clients and not self.__clients[resource].closed

    async def _optionally_bulk_set_users(self, users_: typing.Iterator[users.User]) -&gt; None:
        try:
            client = await self.get_connection(ResourceIndex.USER)
        except ValueError:
            pass
        else:
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))
            # user_setters = []
            # expire_setters: typing.MutableSequence[typing.Coroutine[typing.Any, typing.Any, None]] = []

            for window in redis_iterators.chunk_values(users_):
                processed_window = {int(user.id): self.marshaller.serialize_user(user) for user in window}
                # transaction = client.multi_exec()
                #
                # for user_id in processed_window.keys():
                #     transaction.pexpire(user_id, expire_time)
                #
                # expire_setters.append(transaction.execute())
                await client.mset(processed_window)
                asyncio.gather(*(client.pexpire(user_id, expire_time) for user_id in processed_window.keys()))
                #  TODO: benchmark bulk setting expire with transaction vs this
                # user_setters.append(client.mset(processed_window))
                # expire_setters.extend((client.pexpire(user_id, expire_time) for user_id in processed_window.keys()))

            # asyncio.gather(*user_setters)
            # asyncio.gather(*expire_setters)

    async def _optionally_set_user(self, user: users.User) -&gt; None:
        try:
            client = await self.get_connection(ResourceIndex.USER)
        except ValueError:
            pass
        else:
            data = self.marshaller.serialize_user(user)
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))
            await client.set(int(user.id), data, pexpire=expire_time)

    async def _spawn_connection(self, resource: ResourceIndex) -&gt; None:
        self.__clients[resource] = await aioredis.create_redis_pool(
            address=self.__address,
            db=int(resource),
            password=self.__password,
            ssl=self.__ssl,
            # encoding=&#34;utf-8&#34;,
        )

    async def open(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        if self.__started:
            return

        try:
            # Gather is awaited here so we can assure all clients are started before this returns.
            await asyncio.gather(*map(self._spawn_connection, self._get_indexes()))
        except aioredis.RedisError:
            # Ensure no dangling clients are left if this fails to start.
            clients = self.__clients
            self.__clients = {}
            await asyncio.gather(*map(_close_client, clients.values()))
            raise

        self.subscribe_listeners()
        self.__started = True

    async def close(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # We want to ensure that we both only do anything here if the client was already started when the method was
        # originally called and also that the client is marked as &#34;closed&#34; before this starts severing connections.
        was_started = self.__started
        self.__started = False

        if not was_started:
            return

        self.unsubscribe_listeners()
        clients = self.__clients
        self.__clients = {}
        # Gather is awaited here so we can assure all clients are closed before this returns.
        await asyncio.gather(*map(_close_client, clients.values()))

    @abc.abstractmethod
    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return None

    @abc.abstractmethod
    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.GuildCache" href="#sake.redis.GuildCache">GuildCache</a></li>
<li><a title="sake.redis.InviteCache" href="#sake.redis.InviteCache">InviteCache</a></li>
<li><a title="sake.redis.MemberCache" href="#sake.redis.MemberCache">MemberCache</a></li>
<li><a title="sake.redis.MessageCache" href="#sake.redis.MessageCache">MessageCache</a></li>
<li><a title="sake.redis.PresenceCache" href="#sake.redis.PresenceCache">PresenceCache</a></li>
<li>sake.redis._MeCache</li>
<li>sake.redis._Reference</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sake.redis.ResourceClient.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>) ‑> Sequence[sake.redis.ResourceIndex]</span>
</code></dt>
<dd>
<div class="desc"><p>The index for the resource which this class is linked to.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should be called on specific base classes and will not be
accurate after inheritance.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ResourceIndex</code></dt>
<dd>The index of the resource this class is linked to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
@abc.abstractmethod
def index(cls) -&gt; typing.Sequence[ResourceIndex]:
    &#34;&#34;&#34;The index for the resource which this class is linked to.

    !!! note
        This should be called on specific base classes and will not be
        accurate after inheritance.

    Returns
    -------
    ResourceIndex
        The index of the resource this class is linked to.
    &#34;&#34;&#34;
    return ()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sake.redis.ResourceClient.dispatch"><code class="name">var <span class="ident">dispatch</span> : typing.Optional[hikari_traits.DispatcherAware]</code></dt>
<dd>
<div class="desc"><p>The dispatcher aware client this resource client is tied to, if set.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If this is set then event listeners will be (de)registered
when this resource is opened/closed.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>typing.Optional[hikari.traits.DispatcherAware]</code></dt>
<dd>The dispatcher aware client this resource is tied to if set,
else <code>builtins.None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # As a note, this will only be set if this is actively hooked into event dispatchers
def dispatch(self) -&gt; typing.Optional[hikari_traits.DispatcherAware]:
    &#34;&#34;&#34;The dispatcher aware client this resource client is tied to, if set.

    !!! note
        If this is set then event listeners will be (de)registered
        when this resource is opened/closed.

    Returns
    -------
    typing.Optional[hikari.traits.DispatcherAware]
        The dispatcher aware client this resource is tied to if set,
        else `builtins.None`.
    &#34;&#34;&#34;
    return self.__dispatch</code></pre>
</details>
</dd>
<dt id="sake.redis.ResourceClient.marshaller"><code class="name">var <span class="ident">marshaller</span> : <a title="sake.marshalling.ObjectMarshaller" href="marshalling.html#sake.marshalling.ObjectMarshaller">ObjectMarshaller</a>[bytes]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def marshaller(self) -&gt; marshalling.ObjectMarshaller[bytes]:
    return self.__marshaller</code></pre>
</details>
</dd>
<dt id="sake.redis.ResourceClient.metadata"><code class="name">var <span class="ident">metadata</span> : MutableMapping[str, Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self) -&gt; typing.MutableMapping[str, typing.Any]:
    return self.__metadata</code></pre>
</details>
</dd>
<dt id="sake.redis.ResourceClient.rest"><code class="name">var <span class="ident">rest</span> : hikari_traits.RESTAware</code></dt>
<dd>
<div class="desc"><p>The REST aware client this resource client is tied to.</p>
<p>This is used to build models with a <code>app</code> attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware client this resource is tied to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property  # unlike here where this is 100% required for building models.
def rest(self) -&gt; hikari_traits.RESTAware:
    &#34;&#34;&#34;The REST aware client this resource client is tied to.

    This is used to build models with a `app` attribute.

    Returns
    -------
    hikari.traits.RESTAware
        The REST aware client this resource is tied to.
    &#34;&#34;&#34;
    return self.__rest</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.ResourceClient.get_connection"><code class="name flex">
<span>async def <span class="ident">get_connection</span></span>(<span>self, resource: ResourceIndex, /) ‑> aioredis.commands.Redis</span>
</code></dt>
<dd>
<div class="desc"><p>Get the connection for a specific resource.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resource</code></strong> :&ensp;<code>ResourceIndex</code></dt>
<dd>The index of the resource to get a connection for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>aioredis.Redis</code></dt>
<dd>The connection instance for the specified resource.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>When this method is called on a closed client.</dd>
<dt><code>ValueError</code></dt>
<dd>When you pass an invalid resource for the client.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_connection(self, resource: ResourceIndex, /) -&gt; aioredis.Redis:
    &#34;&#34;&#34;Get the connection for a specific resource.

    Parameters
    ----------
    resource : ResourceIndex
        The index of the resource to get a connection for.

    Returns
    -------
    aioredis.Redis
        The connection instance for the specified resource.

    Raises
    ------
    TypeError
        When this method is called on a closed client.
    ValueError
        When you pass an invalid resource for the client.
    &#34;&#34;&#34;
    if not self.__started:
        raise TypeError(&#34;Cannot use an inactive client&#34;)

    try:
        return self.__clients[resource]
    except KeyError:
        raise ValueError(f&#34;Resource index `{resource}` is invalid for this client&#34;) from None</code></pre>
</details>
</dd>
<dt id="sake.redis.ResourceClient.get_connection_status"><code class="name flex">
<span>async def <span class="ident">get_connection_status</span></span>(<span>self, resource: ResourceIndex, /) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Get the status of the internal connection for a specific resource.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resource</code></strong> :&ensp;<code>ResourceIndex</code></dt>
<dd>The index of the resource to get the status for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the client has an active connection for the specified resource.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_connection_status(self, resource: ResourceIndex, /) -&gt; bool:
    &#34;&#34;&#34;Get the status of the internal connection for a specific resource.

    Parameters
    ----------
    resource : ResourceIndex
        The index of the resource to get the status for.

    Returns
    -------
    bool
        Whether the client has an active connection for the specified resource.
    &#34;&#34;&#34;
    return resource in self.__clients and not self.__clients[resource].closed</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.RoleCache"><code class="flex name class">
<span>class <span class="ident">RoleCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoleCache(_Reference, traits.RoleCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.ROLE,)

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_roles_for_guild(event.guild_id)
        if isinstance(event, (guild_events.GuildAvailableEvent, guild_events.GuildUpdateEvent)) and event.emojis:
            client = await self.get_connection(ResourceIndex.ROLE)
            windows = redis_iterators.chunk_values(event.roles.items())
            setters = (client.mset(_cast_map_window(window, int, self.marshaller.serialize_role)) for window in windows)
            id_setter = self._add_ids(
                ResourceIndex.GUILD, event.guild_id, ResourceIndex.ROLE, *map(int, event.roles.keys())
            )
            asyncio.gather(*setters, id_setter)

    async def __on_role_update(self, event: role_events.RoleEvent) -&gt; None:
        if isinstance(event, (role_events.RoleCreateEvent, role_events.RoleUpdateEvent)):
            await self.set_role(event.role)

        elif isinstance(event, role_events.RoleDeleteEvent):
            await self.delete_role(event.role_id, guild_id=event.guild_id)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(role_events.RoleEvent, self.__on_role_update)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(role_events.RoleEvent, self.__on_role_update)

    async def clear_roles(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        references = await self._dump_relationship(ResourceIndex.GUILD, ResourceIndex.ROLE)
        client = await self.get_connection(ResourceIndex.ROLE)
        asyncio.gather(
            *itertools.starmap(client.delete, redis_iterators.chunk_values(itertools.chain(references.values())))
        )

    async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, cast=bytes)
        if not role_ids:
            return

        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, *role_ids)
        client = await self.get_connection(ResourceIndex.ROLE)
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(role_ids)))

    async def delete_role(
        self, role_id: snowflakes.Snowflakeish, /, *, guild_id: typing.Optional[snowflakes.Snowflakeish] = None
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_id = int(role_id)
        if guild_id is None:
            try:
                guild_id = (await self.get_role(role_id)).guild_id
            except errors.EntryNotFound:
                return

        client = await self.get_connection(ResourceIndex.ROLE)
        await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, role_id)
        await client.delete(role_id)

    async def get_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; guilds.Role:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        role_id = int(role_id)
        client = await self.get_connection(ResourceIndex.ROLE)
        data = await client.get(role_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Role entry `{role_id}` not found&#34;)

        return self.marshaller.deserialize_role(data)

    def iter_roles(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[guilds.Role]:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.ROLE, self.marshaller.deserialize_role, window_size=window_size
        )

    def iter_roles_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[guilds.Role]:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE)
        return redis_iterators.ReferenceIterator(
            self, key, ResourceIndex.ROLE, self.marshaller.deserialize_role, window_size=window_size
        )

    async def set_role(self, role: guilds.Role, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.ROLE)
        await client.set(int(role.id), self.marshaller.serialize_role(role))
        await self._add_ids(ResourceIndex.GUILD, role.guild_id, ResourceIndex.ROLE, int(role.id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.RoleCache" href="traits.html#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.RoleCache.clear_roles_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_roles_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
    role_ids = await self._get_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, cast=bytes)
    if not role_ids:
        return

    await self._delete_ids(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE, *role_ids)
    client = await self.get_connection(ResourceIndex.ROLE)
    # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
    # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
    await asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(role_ids)))</code></pre>
</details>
</dd>
<dt id="sake.redis.RoleCache.iter_roles_for_guild"><code class="name flex">
<span>def <span class="ident">iter_roles_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Role]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_roles_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[guilds.Role]:
    # &lt;&lt;Inherited docstring from sake.traits.RoleCache&gt;&gt;
    key = self._generate_reference_key(ResourceIndex.GUILD, guild_id, ResourceIndex.ROLE)
    return redis_iterators.ReferenceIterator(
        self, key, ResourceIndex.ROLE, self.marshaller.deserialize_role, window_size=window_size
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RoleCache" href="traits.html#sake.traits.RoleCache">RoleCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RoleCache.clear_roles" href="traits.html#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.delete_role" href="traits.html#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.get_role" href="traits.html#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.iter_roles" href="traits.html#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.set_role" href="traits.html#sake.traits.RoleCache.set_role">set_role</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.UserCache"><code class="flex name class">
<span>class <span class="ident">UserCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserCache(_MeCache, traits.UserCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from ResourceClient&gt;&gt;
        return (ResourceIndex.USER,)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # The users cache is a special case as it doesn&#39;t directly map to any events for most user entries.
        super().subscribe_listeners()

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        # The users cache is a special case as it doesn&#39;t directly map to any events for most user entries.
        super().unsubscribe_listeners()

    def with_user_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
        &#34;&#34;&#34;Set the default expire time for user entries added with this client.

        Parameters
        ----------
        expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
            The default expire time to add for users in this cache or `builtins.None`
            to set back to the default behaviour.
            This may either be the number of seconds as an int or float (where
            millisecond precision is supported) or a timedelta.

        Returns
        -------
        ResourceT
            The client this is being called on to enable chained calls.
        &#34;&#34;&#34;
        if expire is not None:
            self.metadata[&#34;expire_user&#34;] = _convert_expire_time(expire)

        elif &#34;expire_user&#34; in self.metadata:
            del self.metadata[&#34;expire_user&#34;]

        return self

    async def clear_users(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        await client.flushdb()

    async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)
        await client.delete(int(user_id))

    async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.USER)
        data = await client.get(user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;User entry `{user_id}` not found&#34;)

        return self.marshaller.deserialize_user(data)

    def iter_users(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[users.User]:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        return redis_iterators.Iterator(
            self, ResourceIndex.USER, self.marshaller.deserialize_user, window_size=window_size
        )

    async def set_user(self, user: users.User, /, *, expire_time: typing.Optional[ExpireT] = None) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.UserCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.USER)

        if expire_time is None:
            expire_time = int(self.metadata.get(&#34;expire_user&#34;, DEFAULT_EXPIRE))

        else:
            expire_time = _convert_expire_time(expire_time)

        await client.set(int(user.id), self.marshaller.serialize_user(user), pexpire=expire_time)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._MeCache</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.MeCache" href="traits.html#sake.traits.MeCache">MeCache</a></li>
<li><a title="sake.traits.UserCache" href="traits.html#sake.traits.UserCache">UserCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.UserCache.with_user_expire"><code class="name flex">
<span>def <span class="ident">with_user_expire</span></span>(<span>self: ResourceT, expire: typing.Optional[ExpireT], /) ‑> ~ResourceT</span>
</code></dt>
<dd>
<div class="desc"><p>Set the default expire time for user entries added with this client.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expire</code></strong> :&ensp;<code>typing.Union[datetime.timedelta, builtins.int, builtins.float]</code></dt>
<dd>The default expire time to add for users in this cache or <code>builtins.None</code>
to set back to the default behaviour.
This may either be the number of seconds as an int or float (where
millisecond precision is supported) or a timedelta.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ResourceT</code></dt>
<dd>The client this is being called on to enable chained calls.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_user_expire(self: ResourceT, expire: typing.Optional[ExpireT], /) -&gt; ResourceT:
    &#34;&#34;&#34;Set the default expire time for user entries added with this client.

    Parameters
    ----------
    expire : typing.Union[datetime.timedelta, builtins.int, builtins.float]
        The default expire time to add for users in this cache or `builtins.None`
        to set back to the default behaviour.
        This may either be the number of seconds as an int or float (where
        millisecond precision is supported) or a timedelta.

    Returns
    -------
    ResourceT
        The client this is being called on to enable chained calls.
    &#34;&#34;&#34;
    if expire is not None:
        self.metadata[&#34;expire_user&#34;] = _convert_expire_time(expire)

    elif &#34;expire_user&#34; in self.metadata:
        del self.metadata[&#34;expire_user&#34;]

    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MeCache" href="traits.html#sake.traits.MeCache">MeCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MeCache.delete_me" href="traits.html#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.traits.MeCache.get_me" href="traits.html#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.traits.MeCache.set_me" href="traits.html#sake.traits.MeCache.set_me">set_me</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.UserCache" href="traits.html#sake.traits.UserCache">UserCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.UserCache.clear_users" href="traits.html#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.traits.UserCache.delete_user" href="traits.html#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.traits.UserCache.get_user" href="traits.html#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.traits.UserCache.iter_users" href="traits.html#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.traits.UserCache.set_user" href="traits.html#sake.traits.UserCache.set_user">set_user</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.redis.VoiceStateCache"><code class="flex name class">
<span>class <span class="ident">VoiceStateCache</span></span>
<span>(</span><span>rest: hikari_traits.RESTAware, dispatch: typing.Optional[hikari_traits.DispatcherAware] = None, /, *, address: typing.Union[str, typing.Tuple[str, typing.Union[str, int]]], password: typing.Optional[str] = None, ssl: typing.Union[ssl_.SSLContext, bool, None] = None, metadata: typing.Optional[typing.MutableMapping[str, typing.Any]] = None, object_marshaller: typing.Optional[marshalling.ObjectMarshaller[bytes]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A base client which all resources in this implementation will implement.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This cannot be initialised by itself and is useless alone.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rest</code></strong> :&ensp;<code>hikari.traits.RESTAware</code></dt>
<dd>The REST aware Hikari client to bind this resource client to.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>typing.Union[str, typing.Tuple[str, typing.Union[str, int]]</code></dt>
<dd>The address to use to connect to the Redis backend server this
resource is linked to. This may either be a string url in the form
of <code>"redis://localhost:4242"</code> or a tuple of an address to a port
in the form of <code>("localhost", 4242)</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dispatch</code></strong> :&ensp;<code>typing.Optional[hikari.traits.DispatchAware]</code></dt>
<dd>The dispatcher aware Hikari client to bind this resource client to.
This can be left as <code>builtins.None</code> to avoid this client from
automatically registering any event listeners.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>typing.Optional[str]</code></dt>
<dd>The password to optionally use to connect ot the backend Redis
server.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>typing.Union[ssl.SSLContext, builtins.bool, builtins.None]</code></dt>
<dd>The SSL context to use when connecting to the Redis backend server,
this may be a context object, bool value or None to leave default
behaviour (which will likely be no SSL).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VoiceStateCache(_Reference, traits.VoiceStateCache):
    __slots__: typing.Sequence[str] = ()

    @classmethod
    def index(cls) -&gt; typing.Sequence[ResourceIndex]:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        return (ResourceIndex.VOICE_STATE,)

    async def __on_guild_channel_delete_event(self, event: channel_events.GuildChannelDeleteEvent) -&gt; None:
        await self.clear_voice_states_for_channel(event.channel_id)

    @staticmethod
    def __generate_references(
        voice_states: typing.Iterable[voices.VoiceState],
        *,
        include_reference_key: bool,
    ) -&gt; typing.MutableMapping[snowflakes.Snowflake, typing.MutableSet[str]]:
        references: typing.MutableMapping[snowflakes.Snowflake, typing.MutableSet[str]] = {}
        for state in voice_states:
            assert state.channel_id is not None, &#34;This channel ID shouldn&#39;t ever be None&#34;
            if state.channel_id not in references:
                references[state.channel_id] = set()
                if not include_reference_key:
                    continue

                references[state.channel_id].add(redis_iterators.HashReferenceIterator.hash_key(state.guild_id))

            references[state.channel_id].add(str(state.user_id))

        return references

    async def __on_guild_visibility_event(self, event: guild_events.GuildVisibilityEvent) -&gt; None:
        # A guild going unavailable is as far as I&#39;m concerned completely irrelevant.
        # Especially since we clear relevant entries on available and other entries are set to expire.
        if isinstance(event, guild_events.GuildUnavailableEvent):
            return

        await self.clear_voice_states_for_guild(event.guild_id)
        if isinstance(event, guild_events.GuildAvailableEvent) and event.voice_states:
            client = await self.get_connection(ResourceIndex.VOICE_STATE)
            windows = redis_iterators.chunk_values(event.voice_states.items())
            setters = (
                client.hmset_dict(
                    int(event.guild_id), _cast_map_window(window, int, self.marshaller.serialize_voice_state)
                )
                for window in windows
            )

            references = self.__generate_references(event.voice_states.values(), include_reference_key=True)
            reference_setters = (
                self._add_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, *state_ids)
                for channel_id, state_ids in references.items()
                if state_ids
            )
            user_setter = self._optionally_bulk_set_users(state.member.user for state in event.voice_states.values())
            asyncio.gather(*setters, user_setter, *reference_setters)

    async def __on_voice_state_update(self, event: voice_events.VoiceStateUpdateEvent) -&gt; None:
        if event.state.channel_id is None:
            await self.delete_voice_state(event.state.guild_id, event.state.user_id)
        else:
            await self.set_voice_state(event.state)

    def subscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().subscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.subscribe(
                channel_events.GuildChannelDeleteEvent, self.__on_guild_channel_delete_event
            )
            self.dispatch.dispatcher.subscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.subscribe(voice_events.VoiceStateUpdateEvent, self.__on_voice_state_update)

    def unsubscribe_listeners(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.Resource&gt;&gt;
        super().unsubscribe_listeners()
        if self.dispatch is not None:
            self.dispatch.dispatcher.unsubscribe(
                channel_events.GuildChannelDeleteEvent, self.__on_guild_channel_delete_event
            )
            self.dispatch.dispatcher.unsubscribe(guild_events.GuildVisibilityEvent, self.__on_guild_visibility_event)
            self.dispatch.dispatcher.unsubscribe(voice_events.VoiceStateUpdateEvent, self.__on_voice_state_update)

    @staticmethod
    def _pop_reference(keys: typing.MutableSequence[bytes]) -&gt; typing.Tuple[bytes, typing.Sequence[bytes]]:
        for key in keys:
            if key.startswith(b&#34;KEY.&#34;):
                keys.remove(key)
                return key[4:], keys

        raise ValueError(&#34;Couldn&#39;t find reference key&#34;)

    async def clear_voice_states(self) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        references = await self._dump_relationship(ResourceIndex.CHANNEL, ResourceIndex.VOICE_STATE)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        asyncio.gather(
            *(client.hdel(key, *values) for key, values in map(self._pop_reference, references.values()) if values)
        )

    async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        states = await self.iter_voice_states_for_guild(guild_id)
        references = self.__generate_references(states, include_reference_key=False)
        id_deleters = (
            self._delete_ids(ResourceIndex.CHANNEL, key, ResourceIndex.VOICE_STATE, *values, reference_key=True)
            for key, values in references.items()
            if values
        )
        entry_deleters = (
            client.hdel(int(guild_id), *values)
            for values in redis_iterators.chunk_values(int(state.user_id) for state in states)
        )
        # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
        # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
        await asyncio.gather(*id_deleters, *entry_deleters)

    async def clear_voice_states_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        ids = await self._get_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, cast=bytes)
        if not ids:
            return

        await self._delete_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, *ids, reference_key=True)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids, window_size=window_size)))

    # We don&#39;t accept channel_id here to avoid the relationship lookup as channel_id isn&#39;t a static value and what we
    # want is the value stored rather than the current or &#34;last&#34; value.
    async def delete_voice_state(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)

        try:
            voice_state = await self.get_voice_state(guild_id, user_id)
        except errors.EntryNotFound:
            pass
        else:
            assert voice_state.channel_id is not None, &#34;Cached voice states should always have a bound channel&#34;
            await client.hdel(int(guild_id), user_id)
            await self._delete_ids(
                ResourceIndex.CHANNEL,
                voice_state.channel_id,
                ResourceIndex.VOICE_STATE,
                user_id,
                reference_key=True,
            )

    async def get_voice_state(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; voices.VoiceState:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        guild_id = int(guild_id)
        user_id = int(user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        data = await client.hget(guild_id, user_id)

        if not data:
            raise errors.EntryNotFound(f&#34;Voice state entry `{user_id}` not found for guild `{guild_id}`&#34;)

        return self.marshaller.deserialize_voice_state(data)

    def iter_voice_states(self, *, window_size: int = WINDOW_SIZE) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        return redis_iterators.MultiMapIterator(
            self, ResourceIndex.VOICE_STATE, self.marshaller.deserialize_voice_state, window_size=window_size
        )

    def iter_voice_states_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        key = self._generate_reference_key(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE)
        return redis_iterators.HashReferenceIterator(
            self,
            key,
            index=ResourceIndex.VOICE_STATE,
            builder=self.marshaller.deserialize_voice_state,
            window_size=window_size,
        )

    def iter_voice_states_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
    ) -&gt; traits.CacheIterator[voices.VoiceState]:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        return redis_iterators.SpecificMapIterator(
            self,
            int(guild_id),
            ResourceIndex.VOICE_STATE,
            self.marshaller.deserialize_voice_state,
            window_size=window_size,
        )

    async def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
        if voice_state.channel_id is None:
            raise ValueError(&#34;Cannot set a voice state which isn&#39;t bound to a channel&#34;)

        data = self.marshaller.serialize_voice_state(voice_state)
        # We have to ensure this is deleted first to make sure previous references are removed.
        await self.delete_voice_state(voice_state.guild_id, voice_state.user_id)
        client = await self.get_connection(ResourceIndex.VOICE_STATE)
        await client.hset(int(voice_state.guild_id), int(voice_state.user_id), data)
        await self._add_ids(
            ResourceIndex.CHANNEL,
            voice_state.channel_id,
            ResourceIndex.VOICE_STATE,
            int(voice_state.user_id),
            redis_iterators.HashReferenceIterator.hash_key(voice_state.guild_id),
        )
        await self._optionally_set_user(voice_state.member.user)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sake.redis._Reference</li>
<li><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.VoiceStateCache" href="traits.html#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Resource" href="traits.html#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.redis.VoiceStateCache.clear_voice_states_for_channel"><code class="name flex">
<span>async def <span class="ident">clear_voice_states_for_channel</span></span>(<span>self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_voice_states_for_channel(
    self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; None:
    # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
    ids = await self._get_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, cast=bytes)
    if not ids:
        return

    await self._delete_ids(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE, *ids, reference_key=True)
    client = await self.get_connection(ResourceIndex.VOICE_STATE)
    asyncio.gather(*itertools.starmap(client.delete, redis_iterators.chunk_values(ids, window_size=window_size)))</code></pre>
</details>
</dd>
<dt id="sake.redis.VoiceStateCache.clear_voice_states_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_voice_states_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
    client = await self.get_connection(ResourceIndex.VOICE_STATE)
    states = await self.iter_voice_states_for_guild(guild_id)
    references = self.__generate_references(states, include_reference_key=False)
    id_deleters = (
        self._delete_ids(ResourceIndex.CHANNEL, key, ResourceIndex.VOICE_STATE, *values, reference_key=True)
        for key, values in references.items()
        if values
    )
    entry_deleters = (
        client.hdel(int(guild_id), *values)
        for values in redis_iterators.chunk_values(int(state.user_id) for state in states)
    )
    # Gather is awaited here to ensure that when internally bulk setting entries after triggering a bulk deletion
    # (based on events) we don&#39;t risk deleting entries after we&#39;ve re-added them.
    await asyncio.gather(*id_deleters, *entry_deleters)</code></pre>
</details>
</dd>
<dt id="sake.redis.VoiceStateCache.iter_voice_states_for_channel"><code class="name flex">
<span>def <span class="ident">iter_voice_states_for_channel</span></span>(<span>self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.voices.VoiceState]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_voice_states_for_channel(
    self, channel_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[voices.VoiceState]:
    # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
    key = self._generate_reference_key(ResourceIndex.CHANNEL, channel_id, ResourceIndex.VOICE_STATE)
    return redis_iterators.HashReferenceIterator(
        self,
        key,
        index=ResourceIndex.VOICE_STATE,
        builder=self.marshaller.deserialize_voice_state,
        window_size=window_size,
    )</code></pre>
</details>
</dd>
<dt id="sake.redis.VoiceStateCache.iter_voice_states_for_guild"><code class="name flex">
<span>def <span class="ident">iter_voice_states_for_guild</span></span>(<span>self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = 1000) ‑> <a title="sake.traits.CacheIterator" href="traits.html#sake.traits.CacheIterator">CacheIterator</a>[hikari.voices.VoiceState]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_voice_states_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /, *, window_size: int = WINDOW_SIZE
) -&gt; traits.CacheIterator[voices.VoiceState]:
    # &lt;&lt;Inherited docstring from sake.traits.VoiceStateCache&gt;&gt;
    return redis_iterators.SpecificMapIterator(
        self,
        int(guild_id),
        ResourceIndex.VOICE_STATE,
        self.marshaller.deserialize_voice_state,
        window_size=window_size,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.subscribe_listeners" href="traits.html#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.redis.ResourceClient.unsubscribe_listeners" href="traits.html#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.redis.ResourceClient.close" href="traits.html#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.open" href="traits.html#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.VoiceStateCache" href="traits.html#sake.traits.VoiceStateCache">VoiceStateCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.VoiceStateCache.clear_voice_states" href="traits.html#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.delete_voice_state" href="traits.html#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.get_voice_state" href="traits.html#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.iter_voice_states" href="traits.html#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.set_voice_state" href="traits.html#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sake" href="index.html">sake</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sake.redis.EmojiCache" href="#sake.redis.EmojiCache">EmojiCache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.redis.GuildCache" href="#sake.redis.GuildCache">GuildCache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.redis.GuildChannelCache" href="#sake.redis.GuildChannelCache">GuildChannelCache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.redis.IntegrationCache" href="#sake.redis.IntegrationCache">IntegrationCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.IntegrationCache.clear_integrations_for_guild" href="#sake.redis.IntegrationCache.clear_integrations_for_guild">clear_integrations_for_guild</a></code></li>
<li><code><a title="sake.redis.IntegrationCache.iter_integrations_for_guild" href="#sake.redis.IntegrationCache.iter_integrations_for_guild">iter_integrations_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.InviteCache" href="#sake.redis.InviteCache">InviteCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.InviteCache.with_invite_expire" href="#sake.redis.InviteCache.with_invite_expire">with_invite_expire</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.MemberCache" href="#sake.redis.MemberCache">MemberCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.MemberCache.clear_members_for_guild" href="#sake.redis.MemberCache.clear_members_for_guild">clear_members_for_guild</a></code></li>
<li><code><a title="sake.redis.MemberCache.iter_members_for_guild" href="#sake.redis.MemberCache.iter_members_for_guild">iter_members_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.MessageCache" href="#sake.redis.MessageCache">MessageCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.MessageCache.with_message_expire" href="#sake.redis.MessageCache.with_message_expire">with_message_expire</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.PresenceCache" href="#sake.redis.PresenceCache">PresenceCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.PresenceCache.clear_presences_for_guild" href="#sake.redis.PresenceCache.clear_presences_for_guild">clear_presences_for_guild</a></code></li>
<li><code><a title="sake.redis.PresenceCache.iter_presences_for_guild" href="#sake.redis.PresenceCache.iter_presences_for_guild">iter_presences_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.RedisCache" href="#sake.redis.RedisCache">RedisCache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.redis.ResourceClient" href="#sake.redis.ResourceClient">ResourceClient</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.ResourceClient.dispatch" href="#sake.redis.ResourceClient.dispatch">dispatch</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection" href="#sake.redis.ResourceClient.get_connection">get_connection</a></code></li>
<li><code><a title="sake.redis.ResourceClient.get_connection_status" href="#sake.redis.ResourceClient.get_connection_status">get_connection_status</a></code></li>
<li><code><a title="sake.redis.ResourceClient.index" href="#sake.redis.ResourceClient.index">index</a></code></li>
<li><code><a title="sake.redis.ResourceClient.marshaller" href="#sake.redis.ResourceClient.marshaller">marshaller</a></code></li>
<li><code><a title="sake.redis.ResourceClient.metadata" href="#sake.redis.ResourceClient.metadata">metadata</a></code></li>
<li><code><a title="sake.redis.ResourceClient.rest" href="#sake.redis.ResourceClient.rest">rest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.RoleCache" href="#sake.redis.RoleCache">RoleCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.RoleCache.clear_roles_for_guild" href="#sake.redis.RoleCache.clear_roles_for_guild">clear_roles_for_guild</a></code></li>
<li><code><a title="sake.redis.RoleCache.iter_roles_for_guild" href="#sake.redis.RoleCache.iter_roles_for_guild">iter_roles_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.UserCache" href="#sake.redis.UserCache">UserCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.UserCache.with_user_expire" href="#sake.redis.UserCache.with_user_expire">with_user_expire</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.redis.VoiceStateCache" href="#sake.redis.VoiceStateCache">VoiceStateCache</a></code></h4>
<ul class="">
<li><code><a title="sake.redis.VoiceStateCache.clear_voice_states_for_channel" href="#sake.redis.VoiceStateCache.clear_voice_states_for_channel">clear_voice_states_for_channel</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.clear_voice_states_for_guild" href="#sake.redis.VoiceStateCache.clear_voice_states_for_guild">clear_voice_states_for_guild</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.iter_voice_states_for_channel" href="#sake.redis.VoiceStateCache.iter_voice_states_for_channel">iter_voice_states_for_channel</a></code></li>
<li><code><a title="sake.redis.VoiceStateCache.iter_voice_states_for_guild" href="#sake.redis.VoiceStateCache.iter_voice_states_for_guild">iter_voice_states_for_guild</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>