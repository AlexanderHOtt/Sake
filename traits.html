<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>sake.traits API documentation</title>
<meta name="description" content="Protocols and abstract classes for the cache resources defined by this standard â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sake.traits</code></h1>
</header>
<section id="section-intro">
<p>Protocols and abstract classes for the cache resources defined by this standard.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the abstract classes defined here, there is no guarantee that the
protocols defined here will be included in the MRO of the classes which
implement them.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# BSD 3-Clause License
#
# Copyright (c) 2020, Faster Speeding
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
&#34;&#34;&#34;Protocols and abstract classes for the cache resources defined by this standard.

!!! note
    Unlike the abstract classes defined here, there is no guarantee that the
    protocols defined here will be included in the MRO of the classes which
    implement them.
&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.Final[typing.Sequence[str]] = [
    &#34;Cache&#34;,
    &#34;CacheIterator&#34;,
    &#34;EmojiCache&#34;,
    &#34;GuildCache&#34;,
    &#34;GuildChannelCache&#34;,
    &#34;IntegrationCache&#34;,
    &#34;InviteCache&#34;,
    &#34;MeCache&#34;,
    &#34;MemberCache&#34;,
    &#34;MessageCache&#34;,
    &#34;PresenceCache&#34;,
    &#34;Resource&#34;,
    &#34;RefCache&#34;,
    &#34;RefEmojiCache&#34;,
    &#34;RefGuildCache&#34;,
    &#34;RefGuildChannelCache&#34;,
    &#34;RefIntegrationCache&#34;,
    &#34;RefInviteCache&#34;,
    &#34;RefMeCache&#34;,
    &#34;RefMemberCache&#34;,
    &#34;RefMessageCache&#34;,
    &#34;RefPresenceCache&#34;,
    &#34;RefRoleCache&#34;,
    &#34;RefUserCache&#34;,
    &#34;RefVoiceStateCache&#34;,
    &#34;RoleCache&#34;,
    &#34;UserCache&#34;,
    &#34;VoiceStateCache&#34;,
]

import abc
import typing

from hikari import iterators

if typing.TYPE_CHECKING:
    from hikari import channels
    from hikari import emojis
    from hikari import guilds
    from hikari import invites
    from hikari import messages
    from hikari import presences
    from hikari import snowflakes
    from hikari import users
    from hikari import voices


ValueT = typing.TypeVar(&#34;ValueT&#34;)


# TODO: should we explicitly raise a ValueError if the wrong object is passed to a set method?
class CacheIterator(iterators.LazyIterator[ValueT], abc.ABC):  # TODO: cascade arguments on referential traits?
    &#34;&#34;&#34;A asynchronous iterator of entries within a defined cache store.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def len(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Get the count of entries that this iterator covers.

        !!! note
            Unlike `hikari.iterators.LazyIterator.count`, this will not exhaust
            the iterator and may return different values as entries are added
            and removed from the cache.

        Returns
        -------
        int
            The count of entries that this iterator covers as of the call.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class Resource(typing.Protocol):
    &#34;&#34;&#34;The basic interface which all cache resources should implement.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def subscribe_listeners(self) -&gt; None:
        &#34;&#34;&#34;Register this resource&#39;s internal listener to a dispatcher aware app.

        !!! note
            Dependent on the implementation, this may be called by
            `Resource.open` and may raise a `builtins.TypeError`if called
            when this resource&#39;s listeners have already been registered.

        !!! note
            If the event dispatcher isn&#39;t provided during initialisation then
            this method will do nothing.
        &#34;&#34;&#34;
        raise NotImplementedError

    def unsubscribe_listeners(self) -&gt; None:
        &#34;&#34;&#34;Unregister this resource&#39;s internal listener to a dispatcher aware app.

        !!! note
            Dependent on the implementation, this may be called by
            `Resource.close` and may raise a `builtins.TypeError`if called
            when this resource&#39;s listeners haven&#39;t been registered yet.

        !!! note
            If the event dispatcher isn&#39;t provided during initialisation then
            this method will do nothing.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def open(self) -&gt; None:
        &#34;&#34;&#34;Startup the resource(s) and allow them to connect to their relevant backend(s).

        !!! note
            This should implicitly call `Resource.subscribe_listeners`.

        !!! note
            This should pass without raising if called on an already opened
            resource.
        &#34;&#34;&#34;
        raise NotImplementedError  # TODO: connection errors.

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the resource(s) and allow them to disconnect from their relevant backend(s).

        !!! note
            This should implicitly call `Resource.unsubscribe_listeners`.

        !!! note
            This should pass without raising if called on an already closed
            resource.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class EmojiCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a emoji cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_emojis(self) -&gt; None:
        &#34;&#34;&#34;Empty the emoji cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove an emoji from the cache.

        Parameters
        ----------
        emoji_id : hikari.snowflakes.Snowflakeish
            The ID of the emoji to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Get an emoji from the cache.

        Parameters
        ----------
        emoji_id : hikari.snowflakes.Snowflakeish
            The ID of the emoji to get from the cache.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The object of the emoji fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_emojis(self) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Iterate over the emojis stored in the cache.

        Returns
        -------
        CacheIterator[hikari.emojis.KnownCustomEmoji]
            An async iterator of the emojis stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        &#34;&#34;&#34;Add an emoji to the cache.

        Parameters
        ----------
        emoji : hikari.emojis.KnownCustomEmoji

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefEmojiCache(EmojiCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial emoji cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove emojis belonging to a specific guild from the cache.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the emojis cached for.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Iterate over the emojis stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the emojis cached for.

        Returns
        -------
        CacheIterator[hikari.emojis.KnownCustomEmoji]
            An async iterator of the emojis stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class GuildCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a guild cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guilds(self) -&gt; None:
        &#34;&#34;&#34;Empty the guild cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
        &#34;&#34;&#34;Get a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get from the cache.

        Returns
        -------
        hikari.guilds.GatewayGuild
            The object of the guild fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guilds(self) -&gt; CacheIterator[guilds.GatewayGuild]:
        &#34;&#34;&#34;Iterate over the guilds stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.GatewayGuild]
            An async iterator of the guilds stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        &#34;&#34;&#34;Add a guild to the cache.

        Parameters
        ----------
        guild : hikari.guilds.GatewayGuild

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


RefGuildCache = GuildCache


@typing.runtime_checkable
class GuildChannelCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a guild channel cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guild_channels(self) -&gt; None:
        &#34;&#34;&#34;Empty the guild channel cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a guild guild channel from the cache.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the guild channel to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; channels.GuildChannel:
        &#34;&#34;&#34;Get a guild channel from the cache.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the guild channel to get from the cache.

        Returns
        -------
        hikari.channels.GuildChannel
            The object of the guild channel fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guild_channels(self) -&gt; CacheIterator[channels.GuildChannel]:
        &#34;&#34;&#34;Iterate over the guild channels stored in the cache.

        Returns
        -------
        CacheIterator[hikari.channels.GuildChannel]
            An async iterator of the guild channels stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        &#34;&#34;&#34;Add a guild channel to the cache.

        Parameters
        ----------
        channel : hikari.channels.GuildChannel

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefGuildChannelCache(GuildChannelCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial guild channel cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guild_channels_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the guild channel cache store for the specified guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached channels for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[channels.GuildChannel]:
        &#34;&#34;&#34;Iterate over the guild channels stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the guild channels cached for it.

        Returns
        -------
        CacheIterator[hikari.channels.GuildChannel]
            An async iterator of the guild channels stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class IntegrationCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a integration cache.&#34;&#34;&#34;

    async def clear_integrations(self) -&gt; None:
        &#34;&#34;&#34;Empty the integration cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove an integration channel from the cache.

        Parameters
        ----------
        integration_id : hikari.snowflakes.Snowflakeish
            The ID of the integration to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; guilds.Integration:
        &#34;&#34;&#34;Get an integration from the cache.

        Parameters
        ----------
        integration_id : hikari.snowflakes.Snowflakeish
            The ID of the integration to get from the cache.

        Returns
        -------
        hikari.guilds.Integration
            The object of the integration fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations(self) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_integration(self, integration: guilds.Integration, /) -&gt; None:
        &#34;&#34;&#34;Add an integration to the cache.

        Parameters
        ----------
        integration : hikari.guilds.Integration
            The integration to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefIntegrationCache(IntegrationCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial invite cache.&#34;&#34;&#34;

    async def clear_integrations_for_application(self, application_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the integrations cached for an application.

        Parameters
        ----------
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to remove cached integrations for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the integrations cached for a guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove cached integrations for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_integration_by_application(
        self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
    ) -&gt; None:
        &#34;&#34;&#34;Remove an integration channel from the cache by the ID of it&#39;s application.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove an integration for.
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to remove an integration for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_integration_by_application(
        self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
    ) -&gt; guilds.Integration:
        &#34;&#34;&#34;Get an integration from the cache by the ID of it&#39;s application.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get an integration for.
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to get an integration for.

        Returns
        -------
        hikari.guilds.Integration
            The object of the integration fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations_for_application(
        self, application_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific application.

        Parameters
        ----------
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to iterate over the cached integrations for.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache for the
            specified application.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the cached integrations for.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache for the
            specified application.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class InviteCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a invite cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_invites(self) -&gt; None:
        &#34;&#34;&#34;Empty the invites cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_invite(self, invite_code: str, /) -&gt; None:
        &#34;&#34;&#34;Remove an invite channel from the cache.

        Parameters
        ----------
        invite_code : builtins.str
            The code of the invite to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_invite(self, invite_code: str, /) -&gt; invites.InviteWithMetadata:
        &#34;&#34;&#34;Get an invite from the cache.

        Parameters
        ----------
        invite_code : builtins.str
            The code of the invite to get from the cache.

        Returns
        -------
        hikari.invites.InviteWithMetadata
            The object of the invite fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites(self) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        &#34;&#34;&#34;Add an invite to the cache.

        Parameters
        ----------
        invite : hikari.invites.InviteWithMetadata
            The invite to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefInviteCache(InviteCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial invite cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_invites_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove invites cached for a specific channel..

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the invites cached for it.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove invites cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the invites cached for it.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the invites cached for.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the invites cached for.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable  # TODO: rename to OwnUserCache
class MeCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a own user cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def delete_me(self) -&gt; None:
        &#34;&#34;&#34;Remove the cached own user entry.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_me(self) -&gt; users.OwnUser:
        &#34;&#34;&#34;Get the own user cache entry.

        Returns
        -------
        hikari.users.OwnUser
            The object of the own user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_me(self, me: users.OwnUser, /) -&gt; None:
        &#34;&#34;&#34;Set the own user entry in the cache.

        Parameters
        ----------
        me : hikari.users.OwnUser
            The own user object to set in the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


RefMeCache = MeCache


@typing.runtime_checkable
class MemberCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a member cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_members(self) -&gt; None:
        &#34;&#34;&#34;Empty the members cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a member from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached member for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached member for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; guilds.Member:
        &#34;&#34;&#34;Get a member from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached member for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached member for.

        Returns
        -------
        hikari.guilds.Member
            The object of the member fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members(
        self,
    ) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_member(self, member: guilds.Member, /) -&gt; None:
        &#34;&#34;&#34;Add a member to the cache.

        Parameters
        ----------
        member : hikari.guilds.Member
            The member to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefMemberCache(MemberCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial member cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the members cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached members for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the members cached for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the cached members for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the members cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the user cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class MessageCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a message cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_messages(self) -&gt; None:
        &#34;&#34;&#34;Empty the messages cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a message from the cache.

        Parameters
        ----------
        message_id : hikari.snowflakes.Snowflakeish
            The ID of the message to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; messages.Message:
        &#34;&#34;&#34;Get a message from the cache.

        Parameters
        ----------
        message_id : hikari.snowflakes.Snowflakeish
            The ID of the message to get from the cache.

        Returns
        -------
        hikari.messages.Message
            The object of the message fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages(self) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_message(self, message: messages.Message, /) -&gt; None:
        &#34;&#34;&#34;Add a message to the cache.

        Parameters
        ----------
        message : hikari.messages.Message
            The message to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def update_message(self, message: messages.PartialMessage, /) -&gt; bool:
        &#34;&#34;&#34;Update a message in the cache using a partial message object.

        !!! note
            This won&#39;t be able to do anything unless an older version of the
            passed message is already cached.

        Parameters
        ----------
        message : messages.PartialMessage
            The partial object of the message to update in the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        # This is a special case method for handling the partial message updates we get
        raise NotImplementedError


@typing.runtime_checkable
class RefMessageCache(MessageCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial message cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific author.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_messages_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific author.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_message_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class PresenceCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a presence cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_presences(self) -&gt; None:
        &#34;&#34;&#34;Empty the presences cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_presence(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a presence from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached presence for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached presence for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_presence(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; presences.MemberPresence:
        &#34;&#34;&#34;Get a presence from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached presence for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached presence for.

        Returns
        -------
        hikari.presences.MemberPresence
            The object of the presence fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences(
        self,
    ) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        &#34;&#34;&#34;Add a presence to the cache.

        Parameters
        ----------
        presence : hikari.presences.MemberPresence
            The presence to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefPresenceCache(PresenceCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial presence cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the presences cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached presences for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the presences cached for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the cached presences for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the cached presences for.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to iterate over the cached presences for.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RoleCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a role cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_roles(self) -&gt; None:
        &#34;&#34;&#34;Empty the roles cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a role from the cache.

        Parameters
        ----------
        role_id : hikari.snowflakes.Snowflakeish
            The ID of the role to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; guilds.Role:
        &#34;&#34;&#34;Get a role from the cache.

        Parameters
        ----------
        role_id : hikari.snowflakes.Snowflakeish
            The ID of the role to get from the cache.

        Returns
        -------
        hikari.guilds.Role
            The object of the role fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_roles(self) -&gt; CacheIterator[guilds.Role]:
        &#34;&#34;&#34;Iterate over the roles stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Role]
            An async iterator of the roles stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_role(self, role: guilds.Role, /) -&gt; None:
        &#34;&#34;&#34;Add a role to the cache.

        Parameters
        ----------
        role : hikari.guilds.Role
            The role to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefRoleCache(RoleCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial role cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the roles cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached roles for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Role]:
        &#34;&#34;&#34;Iterate over the roles stored in the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the roles cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Role]
            An async iterator of the roles stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class UserCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a cache implementation which supports a user cache.

    !!! note
        Unlike other resources, user doesn&#39;t have any events which
        directly update it and may only be updated through event
        listeners when resources which reference it are also included.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_users(self) -&gt; None:  # TODO: cascade
        &#34;&#34;&#34;Empty the users cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
        &#34;&#34;&#34;Get a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get from the cache.

        Returns
        -------
        hikari.users.User
            The object of the user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_users(self) -&gt; CacheIterator[users.User]:
        &#34;&#34;&#34;Iterate over the users stored in the cache.

        Returns
        -------
        CacheIterator[hikari.users.User]
            An async iterator of the users stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_user(self, user: users.User, /) -&gt; None:
        &#34;&#34;&#34;Add a user to the cache.

        Parameters
        ----------
        user : hikari.users.User
            The user to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


RefUserCache = UserCache


@typing.runtime_checkable
class VoiceStateCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a voice state cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_voice_states(self) -&gt; None:
        &#34;&#34;&#34;Empty the voice states cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_voice_state(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a voice state from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached voice state for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached voice state for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_voice_state(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; voices.VoiceState:
        &#34;&#34;&#34;Get a voice state from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached voice state for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached voice state for.

        Returns
        -------
        hikari.voices.VoiceState
            The object of the voice state fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states(self) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        &#34;&#34;&#34;Add a voice state to the cache.

        Parameters
        ----------
        voice_state : hikari.voices.VoiceState
            The voice state to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class RefVoiceStateCache(VoiceStateCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial voice state cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()  # TODO: for user?

    async def clear_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the voice states cached for a specified channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the voice states cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the voice states cached for a specified guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the voice states cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the voice states cached for.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the voice states cached for.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError


@typing.runtime_checkable
class Cache(
    GuildCache,
    EmojiCache,
    GuildChannelCache,
    IntegrationCache,
    InviteCache,
    MeCache,
    MemberCache,
    MessageCache,
    PresenceCache,
    RoleCache,
    UserCache,
    VoiceStateCache,
    typing.Protocol,
):
    &#34;&#34;&#34;Protocol of a cache which implements all the defined resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()


@typing.runtime_checkable
class RefCache(
    Cache,
    RefGuildCache,
    RefEmojiCache,
    RefGuildChannelCache,
    RefIntegrationCache,
    RefInviteCache,
    RefMeCache,
    RefMemberCache,
    RefMessageCache,
    RefPresenceCache,
    RefRoleCache,
    RefUserCache,
    RefVoiceStateCache,
    typing.Protocol,
):
    &#34;&#34;&#34;Protocol of a cache which implements all the defined reference resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sake.traits.Cache"><code class="flex name class">
<span>class <span class="ident">Cache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol of a cache which implements all the defined resources.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class Cache(
    GuildCache,
    EmojiCache,
    GuildChannelCache,
    IntegrationCache,
    InviteCache,
    MeCache,
    MemberCache,
    MessageCache,
    PresenceCache,
    RoleCache,
    UserCache,
    VoiceStateCache,
    typing.Protocol,
):
    &#34;&#34;&#34;Protocol of a cache which implements all the defined resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></li>
<li><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></li>
<li><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RedisCache" href="redis.html#sake.redis.RedisCache">RedisCache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.GuildCache.clear_guilds" href="#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.GuildCache.delete_guild" href="#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.get_guild" href="#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.iter_guilds" href="#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.GuildCache.set_guild" href="#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.GuildCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.EmojiCache.clear_emojis" href="#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.delete_emoji" href="#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.get_emoji" href="#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.iter_emojis" href="#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.set_emoji" href="#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.GuildChannelCache.clear_guild_channels" href="#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.delete_guild_channel" href="#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.get_guild_channel" href="#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.iter_guild_channels" href="#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.set_guild_channel" href="#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.IntegrationCache.clear_integrations" href="#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.delete_integration" href="#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.get_integration" href="#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.iter_integrations" href="#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.set_integration" href="#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.InviteCache.clear_invites" href="#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.delete_invite" href="#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.get_invite" href="#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.iter_invites" href="#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.set_invite" href="#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MeCache.delete_me" href="#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.traits.MeCache.get_me" href="#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.traits.MeCache.set_me" href="#sake.traits.MeCache.set_me">set_me</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MemberCache.clear_members" href="#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.delete_member" href="#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.get_member" href="#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.iter_members" href="#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.set_member" href="#sake.traits.MemberCache.set_member">set_member</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MessageCache.clear_messages" href="#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.delete_message" href="#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.get_message" href="#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.iter_messages" href="#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.set_message" href="#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.update_message" href="#sake.traits.MessageCache.update_message">update_message</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.PresenceCache.clear_presences" href="#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.delete_presence" href="#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.get_presence" href="#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.iter_presences" href="#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.set_presence" href="#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RoleCache.clear_roles" href="#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.delete_role" href="#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.get_role" href="#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.iter_roles" href="#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.set_role" href="#sake.traits.RoleCache.set_role">set_role</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.UserCache.clear_users" href="#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.traits.UserCache.delete_user" href="#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.traits.UserCache.get_user" href="#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.traits.UserCache.iter_users" href="#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.traits.UserCache.set_user" href="#sake.traits.UserCache.set_user">set_user</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.VoiceStateCache.clear_voice_states" href="#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.delete_voice_state" href="#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.get_voice_state" href="#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.iter_voice_states" href="#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.set_voice_state" href="#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.CacheIterator"><code class="flex name class">
<span>class <span class="ident">CacheIterator</span></span>
</code></dt>
<dd>
<div class="desc"><p>A asynchronous iterator of entries within a defined cache store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CacheIterator(iterators.LazyIterator[ValueT], abc.ABC):  # TODO: cascade arguments on referential traits?
    &#34;&#34;&#34;A asynchronous iterator of entries within a defined cache store.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def len(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Get the count of entries that this iterator covers.

        !!! note
            Unlike `hikari.iterators.LazyIterator.count`, this will not exhaust
            the iterator and may return different values as entries are added
            and removed from the cache.

        Returns
        -------
        int
            The count of entries that this iterator covers as of the call.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hikari.iterators.LazyIterator</li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis_iterators.HashReferenceIterator" href="redis_iterators.html#sake.redis_iterators.HashReferenceIterator">HashReferenceIterator</a></li>
<li><a title="sake.redis_iterators.Iterator" href="redis_iterators.html#sake.redis_iterators.Iterator">Iterator</a></li>
<li><a title="sake.redis_iterators.MultiMapIterator" href="redis_iterators.html#sake.redis_iterators.MultiMapIterator">MultiMapIterator</a></li>
<li>sake.redis_iterators.ReferenceIterator</li>
<li><a title="sake.redis_iterators.SpecificMapIterator" href="redis_iterators.html#sake.redis_iterators.SpecificMapIterator">SpecificMapIterator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.CacheIterator.len"><code class="name flex">
<span>async def <span class="ident">len</span></span>(<span>self) â€‘>Â Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the count of entries that this iterator covers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike <code>hikari.iterators.LazyIterator.count</code>, this will not exhaust
the iterator and may return different values as entries are added
and removed from the cache.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The count of entries that this iterator covers as of the call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
async def len(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;Get the count of entries that this iterator covers.

    !!! note
        Unlike `hikari.iterators.LazyIterator.count`, this will not exhaust
        the iterator and may return different values as entries are added
        and removed from the cache.

    Returns
    -------
    int
        The count of entries that this iterator covers as of the call.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sake.traits.EmojiCache"><code class="flex name class">
<span>class <span class="ident">EmojiCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a emoji cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class EmojiCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a emoji cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_emojis(self) -&gt; None:
        &#34;&#34;&#34;Empty the emoji cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove an emoji from the cache.

        Parameters
        ----------
        emoji_id : hikari.snowflakes.Snowflakeish
            The ID of the emoji to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Get an emoji from the cache.

        Parameters
        ----------
        emoji_id : hikari.snowflakes.Snowflakeish
            The ID of the emoji to get from the cache.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The object of the emoji fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_emojis(self) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Iterate over the emojis stored in the cache.

        Returns
        -------
        CacheIterator[hikari.emojis.KnownCustomEmoji]
            An async iterator of the emojis stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        &#34;&#34;&#34;Add an emoji to the cache.

        Parameters
        ----------
        emoji : hikari.emojis.KnownCustomEmoji

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefEmojiCache" href="#sake.traits.RefEmojiCache">RefEmojiCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.EmojiCache.clear_emojis"><code class="name flex">
<span>async def <span class="ident">clear_emojis</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the emoji cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_emojis(self) -&gt; None:
    &#34;&#34;&#34;Empty the emoji cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.EmojiCache.delete_emoji"><code class="name flex">
<span>async def <span class="ident">delete_emoji</span></span>(<span>self, emoji_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the emoji to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove an emoji from the cache.

    Parameters
    ----------
    emoji_id : hikari.snowflakes.Snowflakeish
        The ID of the emoji to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.EmojiCache.get_emoji"><code class="name flex">
<span>async def <span class="ident">get_emoji</span></span>(<span>self, emoji_id:Â snowflakes.Snowflakeish, /) â€‘>Â emojis.KnownCustomEmoji</span>
</code></dt>
<dd>
<div class="desc"><p>Get an emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the emoji to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.emojis.KnownCustomEmoji</code></dt>
<dd>The object of the emoji fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_emoji(self, emoji_id: snowflakes.Snowflakeish, /) -&gt; emojis.KnownCustomEmoji:
    &#34;&#34;&#34;Get an emoji from the cache.

    Parameters
    ----------
    emoji_id : hikari.snowflakes.Snowflakeish
        The ID of the emoji to get from the cache.

    Returns
    -------
    hikari.emojis.KnownCustomEmoji
        The object of the emoji fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.EmojiCache.iter_emojis"><code class="name flex">
<span>def <span class="ident">iter_emojis</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[emojis.KnownCustomEmoji]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the emojis stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.emojis.KnownCustomEmoji]</code></dt>
<dd>An async iterator of the emojis stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_emojis(self) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
    &#34;&#34;&#34;Iterate over the emojis stored in the cache.

    Returns
    -------
    CacheIterator[hikari.emojis.KnownCustomEmoji]
        An async iterator of the emojis stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.EmojiCache.set_emoji"><code class="name flex">
<span>async def <span class="ident">set_emoji</span></span>(<span>self, emoji:Â emojis.KnownCustomEmoji, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an emoji to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code>hikari.emojis.KnownCustomEmoji</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
    &#34;&#34;&#34;Add an emoji to the cache.

    Parameters
    ----------
    emoji : hikari.emojis.KnownCustomEmoji

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.GuildCache"><code class="flex name class">
<span>class <span class="ident">GuildCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a guild cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class GuildCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a guild cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guilds(self) -&gt; None:
        &#34;&#34;&#34;Empty the guild cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
        &#34;&#34;&#34;Get a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get from the cache.

        Returns
        -------
        hikari.guilds.GatewayGuild
            The object of the guild fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guilds(self) -&gt; CacheIterator[guilds.GatewayGuild]:
        &#34;&#34;&#34;Iterate over the guilds stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.GatewayGuild]
            An async iterator of the guilds stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        &#34;&#34;&#34;Add a guild to the cache.

        Parameters
        ----------
        guild : hikari.guilds.GatewayGuild

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.GuildCache" href="redis.html#sake.redis.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.GuildCache.clear_guilds"><code class="name flex">
<span>async def <span class="ident">clear_guilds</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the guild cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_guilds(self) -&gt; None:
    &#34;&#34;&#34;Empty the guild cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.delete_guild"><code class="name flex">
<span>async def <span class="ident">delete_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a guild from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.get_guild"><code class="name flex">
<span>async def <span class="ident">get_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.GatewayGuild</span>
</code></dt>
<dd>
<div class="desc"><p>Get a guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.GatewayGuild</code></dt>
<dd>The object of the guild fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
    &#34;&#34;&#34;Get a guild from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get from the cache.

    Returns
    -------
    hikari.guilds.GatewayGuild
        The object of the guild fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.iter_guilds"><code class="name flex">
<span>def <span class="ident">iter_guilds</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.GatewayGuild]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the guilds stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.GatewayGuild]</code></dt>
<dd>An async iterator of the guilds stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_guilds(self) -&gt; CacheIterator[guilds.GatewayGuild]:
    &#34;&#34;&#34;Iterate over the guilds stored in the cache.

    Returns
    -------
    CacheIterator[hikari.guilds.GatewayGuild]
        An async iterator of the guilds stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.set_guild"><code class="name flex">
<span>async def <span class="ident">set_guild</span></span>(<span>self, guild:Â guilds.GatewayGuild, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a guild to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code>hikari.guilds.GatewayGuild</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
    &#34;&#34;&#34;Add a guild to the cache.

    Parameters
    ----------
    guild : hikari.guilds.GatewayGuild

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sake.traits.GuildCache"><code class="flex name class">
<span>class <span class="ident">RefGuildCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a guild cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class GuildCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a guild cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guilds(self) -&gt; None:
        &#34;&#34;&#34;Empty the guild cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
        &#34;&#34;&#34;Get a guild from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get from the cache.

        Returns
        -------
        hikari.guilds.GatewayGuild
            The object of the guild fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guilds(self) -&gt; CacheIterator[guilds.GatewayGuild]:
        &#34;&#34;&#34;Iterate over the guilds stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.GatewayGuild]
            An async iterator of the guilds stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        &#34;&#34;&#34;Add a guild to the cache.

        Parameters
        ----------
        guild : hikari.guilds.GatewayGuild

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.GuildCache" href="redis.html#sake.redis.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.GuildCache.clear_guilds"><code class="name flex">
<span>async def <span class="ident">clear_guilds</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the guild cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_guilds(self) -&gt; None:
    &#34;&#34;&#34;Empty the guild cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.delete_guild"><code class="name flex">
<span>async def <span class="ident">delete_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a guild from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.get_guild"><code class="name flex">
<span>async def <span class="ident">get_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.GatewayGuild</span>
</code></dt>
<dd>
<div class="desc"><p>Get a guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.GatewayGuild</code></dt>
<dd>The object of the guild fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; guilds.GatewayGuild:
    &#34;&#34;&#34;Get a guild from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get from the cache.

    Returns
    -------
    hikari.guilds.GatewayGuild
        The object of the guild fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.iter_guilds"><code class="name flex">
<span>def <span class="ident">iter_guilds</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.GatewayGuild]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the guilds stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.GatewayGuild]</code></dt>
<dd>An async iterator of the guilds stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_guilds(self) -&gt; CacheIterator[guilds.GatewayGuild]:
    &#34;&#34;&#34;Iterate over the guilds stored in the cache.

    Returns
    -------
    CacheIterator[hikari.guilds.GatewayGuild]
        An async iterator of the guilds stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildCache.set_guild"><code class="name flex">
<span>async def <span class="ident">set_guild</span></span>(<span>self, guild:Â guilds.GatewayGuild, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a guild to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code>hikari.guilds.GatewayGuild</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
    &#34;&#34;&#34;Add a guild to the cache.

    Parameters
    ----------
    guild : hikari.guilds.GatewayGuild

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.GuildChannelCache"><code class="flex name class">
<span>class <span class="ident">GuildChannelCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a guild channel cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class GuildChannelCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a guild channel cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guild_channels(self) -&gt; None:
        &#34;&#34;&#34;Empty the guild channel cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a guild guild channel from the cache.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the guild channel to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; channels.GuildChannel:
        &#34;&#34;&#34;Get a guild channel from the cache.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the guild channel to get from the cache.

        Returns
        -------
        hikari.channels.GuildChannel
            The object of the guild channel fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guild_channels(self) -&gt; CacheIterator[channels.GuildChannel]:
        &#34;&#34;&#34;Iterate over the guild channels stored in the cache.

        Returns
        -------
        CacheIterator[hikari.channels.GuildChannel]
            An async iterator of the guild channels stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        &#34;&#34;&#34;Add a guild channel to the cache.

        Parameters
        ----------
        channel : hikari.channels.GuildChannel

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefGuildChannelCache" href="#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.GuildChannelCache.clear_guild_channels"><code class="name flex">
<span>async def <span class="ident">clear_guild_channels</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the guild channel cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_guild_channels(self) -&gt; None:
    &#34;&#34;&#34;Empty the guild channel cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildChannelCache.delete_guild_channel"><code class="name flex">
<span>async def <span class="ident">delete_guild_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a guild guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild channel to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a guild guild channel from the cache.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the guild channel to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildChannelCache.get_guild_channel"><code class="name flex">
<span>async def <span class="ident">get_guild_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â channels.GuildChannel</span>
</code></dt>
<dd>
<div class="desc"><p>Get a guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild channel to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.channels.GuildChannel</code></dt>
<dd>The object of the guild channel fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_guild_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; channels.GuildChannel:
    &#34;&#34;&#34;Get a guild channel from the cache.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the guild channel to get from the cache.

    Returns
    -------
    hikari.channels.GuildChannel
        The object of the guild channel fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildChannelCache.iter_guild_channels"><code class="name flex">
<span>def <span class="ident">iter_guild_channels</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[channels.GuildChannel]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the guild channels stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.channels.GuildChannel]</code></dt>
<dd>An async iterator of the guild channels stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_guild_channels(self) -&gt; CacheIterator[channels.GuildChannel]:
    &#34;&#34;&#34;Iterate over the guild channels stored in the cache.

    Returns
    -------
    CacheIterator[hikari.channels.GuildChannel]
        An async iterator of the guild channels stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.GuildChannelCache.set_guild_channel"><code class="name flex">
<span>async def <span class="ident">set_guild_channel</span></span>(<span>self, channel:Â channels.GuildChannel, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a guild channel to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>hikari.channels.GuildChannel</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
    &#34;&#34;&#34;Add a guild channel to the cache.

    Parameters
    ----------
    channel : hikari.channels.GuildChannel

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.IntegrationCache"><code class="flex name class">
<span>class <span class="ident">IntegrationCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a integration cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class IntegrationCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a integration cache.&#34;&#34;&#34;

    async def clear_integrations(self) -&gt; None:
        &#34;&#34;&#34;Empty the integration cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove an integration channel from the cache.

        Parameters
        ----------
        integration_id : hikari.snowflakes.Snowflakeish
            The ID of the integration to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; guilds.Integration:
        &#34;&#34;&#34;Get an integration from the cache.

        Parameters
        ----------
        integration_id : hikari.snowflakes.Snowflakeish
            The ID of the integration to get from the cache.

        Returns
        -------
        hikari.guilds.Integration
            The object of the integration fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations(self) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_integration(self, integration: guilds.Integration, /) -&gt; None:
        &#34;&#34;&#34;Add an integration to the cache.

        Parameters
        ----------
        integration : hikari.guilds.Integration
            The integration to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.IntegrationCache" href="redis.html#sake.redis.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefIntegrationCache" href="#sake.traits.RefIntegrationCache">RefIntegrationCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.IntegrationCache.clear_integrations"><code class="name flex">
<span>async def <span class="ident">clear_integrations</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the integration cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_integrations(self) -&gt; None:
    &#34;&#34;&#34;Empty the integration cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.IntegrationCache.delete_integration"><code class="name flex">
<span>async def <span class="ident">delete_integration</span></span>(<span>self, integration_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an integration channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>integration_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the integration to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove an integration channel from the cache.

    Parameters
    ----------
    integration_id : hikari.snowflakes.Snowflakeish
        The ID of the integration to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.IntegrationCache.get_integration"><code class="name flex">
<span>async def <span class="ident">get_integration</span></span>(<span>self, integration_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.Integration</span>
</code></dt>
<dd>
<div class="desc"><p>Get an integration from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>integration_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the integration to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.Integration</code></dt>
<dd>The object of the integration fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_integration(self, integration_id: snowflakes.Snowflakeish, /) -&gt; guilds.Integration:
    &#34;&#34;&#34;Get an integration from the cache.

    Parameters
    ----------
    integration_id : hikari.snowflakes.Snowflakeish
        The ID of the integration to get from the cache.

    Returns
    -------
    hikari.guilds.Integration
        The object of the integration fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.IntegrationCache.iter_integrations"><code class="name flex">
<span>def <span class="ident">iter_integrations</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Integration]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the integrations stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Integration]</code></dt>
<dd>An async iterator of the integrations stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_integrations(self) -&gt; CacheIterator[guilds.Integration]:
    &#34;&#34;&#34;Iterate over the integrations stored in the cache.

    Returns
    -------
    CacheIterator[hikari.guilds.Integration]
        An async iterator of the integrations stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.IntegrationCache.set_integration"><code class="name flex">
<span>async def <span class="ident">set_integration</span></span>(<span>self, integration:Â guilds.Integration, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an integration to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>integration</code></strong> :&ensp;<code>hikari.guilds.Integration</code></dt>
<dd>The integration to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_integration(self, integration: guilds.Integration, /) -&gt; None:
    &#34;&#34;&#34;Add an integration to the cache.

    Parameters
    ----------
    integration : hikari.guilds.Integration
        The integration to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.InviteCache"><code class="flex name class">
<span>class <span class="ident">InviteCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a invite cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class InviteCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a invite cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_invites(self) -&gt; None:
        &#34;&#34;&#34;Empty the invites cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_invite(self, invite_code: str, /) -&gt; None:
        &#34;&#34;&#34;Remove an invite channel from the cache.

        Parameters
        ----------
        invite_code : builtins.str
            The code of the invite to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_invite(self, invite_code: str, /) -&gt; invites.InviteWithMetadata:
        &#34;&#34;&#34;Get an invite from the cache.

        Parameters
        ----------
        invite_code : builtins.str
            The code of the invite to get from the cache.

        Returns
        -------
        hikari.invites.InviteWithMetadata
            The object of the invite fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites(self) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        &#34;&#34;&#34;Add an invite to the cache.

        Parameters
        ----------
        invite : hikari.invites.InviteWithMetadata
            The invite to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.InviteCache" href="redis.html#sake.redis.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefInviteCache" href="#sake.traits.RefInviteCache">RefInviteCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.InviteCache.clear_invites"><code class="name flex">
<span>async def <span class="ident">clear_invites</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the invites cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_invites(self) -&gt; None:
    &#34;&#34;&#34;Empty the invites cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.InviteCache.delete_invite"><code class="name flex">
<span>async def <span class="ident">delete_invite</span></span>(<span>self, invite_code:Â str, /) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an invite channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite_code</code></strong> :&ensp;<code>builtins.str</code></dt>
<dd>The code of the invite to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_invite(self, invite_code: str, /) -&gt; None:
    &#34;&#34;&#34;Remove an invite channel from the cache.

    Parameters
    ----------
    invite_code : builtins.str
        The code of the invite to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.InviteCache.get_invite"><code class="name flex">
<span>async def <span class="ident">get_invite</span></span>(<span>self, invite_code:Â str, /) â€‘>Â invites.InviteWithMetadata</span>
</code></dt>
<dd>
<div class="desc"><p>Get an invite from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite_code</code></strong> :&ensp;<code>builtins.str</code></dt>
<dd>The code of the invite to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.invites.InviteWithMetadata</code></dt>
<dd>The object of the invite fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_invite(self, invite_code: str, /) -&gt; invites.InviteWithMetadata:
    &#34;&#34;&#34;Get an invite from the cache.

    Parameters
    ----------
    invite_code : builtins.str
        The code of the invite to get from the cache.

    Returns
    -------
    hikari.invites.InviteWithMetadata
        The object of the invite fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.InviteCache.iter_invites"><code class="name flex">
<span>def <span class="ident">iter_invites</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[invites.InviteWithMetadata]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the invites stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.invites.InviteWithMetadata]</code></dt>
<dd>An async iterator of the invites stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_invites(self) -&gt; CacheIterator[invites.InviteWithMetadata]:
    &#34;&#34;&#34;Iterate over the invites stored in the cache.

    Returns
    -------
    CacheIterator[hikari.invites.InviteWithMetadata]
        An async iterator of the invites stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.InviteCache.set_invite"><code class="name flex">
<span>async def <span class="ident">set_invite</span></span>(<span>self, invite:Â invites.InviteWithMetadata, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an invite to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code>hikari.invites.InviteWithMetadata</code></dt>
<dd>The invite to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
    &#34;&#34;&#34;Add an invite to the cache.

    Parameters
    ----------
    invite : hikari.invites.InviteWithMetadata
        The invite to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.MeCache"><code class="flex name class">
<span>class <span class="ident">MeCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a own user cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable  # TODO: rename to OwnUserCache
class MeCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a own user cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def delete_me(self) -&gt; None:
        &#34;&#34;&#34;Remove the cached own user entry.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_me(self) -&gt; users.OwnUser:
        &#34;&#34;&#34;Get the own user cache entry.

        Returns
        -------
        hikari.users.OwnUser
            The object of the own user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_me(self, me: users.OwnUser, /) -&gt; None:
        &#34;&#34;&#34;Set the own user entry in the cache.

        Parameters
        ----------
        me : hikari.users.OwnUser
            The own user object to set in the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sake.redis._MeCache</li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.MeCache.delete_me"><code class="name flex">
<span>async def <span class="ident">delete_me</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the cached own user entry.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_me(self) -&gt; None:
    &#34;&#34;&#34;Remove the cached own user entry.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MeCache.get_me"><code class="name flex">
<span>async def <span class="ident">get_me</span></span>(<span>self) â€‘>Â users.OwnUser</span>
</code></dt>
<dd>
<div class="desc"><p>Get the own user cache entry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.users.OwnUser</code></dt>
<dd>The object of the own user fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_me(self) -&gt; users.OwnUser:
    &#34;&#34;&#34;Get the own user cache entry.

    Returns
    -------
    hikari.users.OwnUser
        The object of the own user fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MeCache.set_me"><code class="name flex">
<span>async def <span class="ident">set_me</span></span>(<span>self, me:Â users.OwnUser, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the own user entry in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>me</code></strong> :&ensp;<code>hikari.users.OwnUser</code></dt>
<dd>The own user object to set in the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_me(self, me: users.OwnUser, /) -&gt; None:
    &#34;&#34;&#34;Set the own user entry in the cache.

    Parameters
    ----------
    me : hikari.users.OwnUser
        The own user object to set in the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sake.traits.MeCache"><code class="flex name class">
<span>class <span class="ident">RefMeCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a own user cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable  # TODO: rename to OwnUserCache
class MeCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a own user cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def delete_me(self) -&gt; None:
        &#34;&#34;&#34;Remove the cached own user entry.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_me(self) -&gt; users.OwnUser:
        &#34;&#34;&#34;Get the own user cache entry.

        Returns
        -------
        hikari.users.OwnUser
            The object of the own user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_me(self, me: users.OwnUser, /) -&gt; None:
        &#34;&#34;&#34;Set the own user entry in the cache.

        Parameters
        ----------
        me : hikari.users.OwnUser
            The own user object to set in the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>sake.redis._MeCache</li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.MeCache.delete_me"><code class="name flex">
<span>async def <span class="ident">delete_me</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the cached own user entry.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_me(self) -&gt; None:
    &#34;&#34;&#34;Remove the cached own user entry.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MeCache.get_me"><code class="name flex">
<span>async def <span class="ident">get_me</span></span>(<span>self) â€‘>Â users.OwnUser</span>
</code></dt>
<dd>
<div class="desc"><p>Get the own user cache entry.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.users.OwnUser</code></dt>
<dd>The object of the own user fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_me(self) -&gt; users.OwnUser:
    &#34;&#34;&#34;Get the own user cache entry.

    Returns
    -------
    hikari.users.OwnUser
        The object of the own user fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MeCache.set_me"><code class="name flex">
<span>async def <span class="ident">set_me</span></span>(<span>self, me:Â users.OwnUser, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the own user entry in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>me</code></strong> :&ensp;<code>hikari.users.OwnUser</code></dt>
<dd>The own user object to set in the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_me(self, me: users.OwnUser, /) -&gt; None:
    &#34;&#34;&#34;Set the own user entry in the cache.

    Parameters
    ----------
    me : hikari.users.OwnUser
        The own user object to set in the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.MemberCache"><code class="flex name class">
<span>class <span class="ident">MemberCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a member cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class MemberCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a member cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_members(self) -&gt; None:
        &#34;&#34;&#34;Empty the members cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a member from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached member for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached member for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; guilds.Member:
        &#34;&#34;&#34;Get a member from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached member for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached member for.

        Returns
        -------
        hikari.guilds.Member
            The object of the member fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members(
        self,
    ) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_member(self, member: guilds.Member, /) -&gt; None:
        &#34;&#34;&#34;Add a member to the cache.

        Parameters
        ----------
        member : hikari.guilds.Member
            The member to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.MemberCache" href="redis.html#sake.redis.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefMemberCache" href="#sake.traits.RefMemberCache">RefMemberCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.MemberCache.clear_members"><code class="name flex">
<span>async def <span class="ident">clear_members</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the members cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_members(self) -&gt; None:
    &#34;&#34;&#34;Empty the members cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MemberCache.delete_member"><code class="name flex">
<span>async def <span class="ident">delete_member</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a member from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove a cached member for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove a cached member for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a member from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove a cached member for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove a cached member for.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MemberCache.get_member"><code class="name flex">
<span>async def <span class="ident">get_member</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.Member</span>
</code></dt>
<dd>
<div class="desc"><p>Get a member from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get a cached member for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to get a cached member for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.Member</code></dt>
<dd>The object of the member fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_member(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; guilds.Member:
    &#34;&#34;&#34;Get a member from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get a cached member for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to get a cached member for.

    Returns
    -------
    hikari.guilds.Member
        The object of the member fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MemberCache.iter_members"><code class="name flex">
<span>def <span class="ident">iter_members</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Member]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the members stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Member]</code></dt>
<dd>An async iterator of the members stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_members(
    self,
) -&gt; CacheIterator[guilds.Member]:
    &#34;&#34;&#34;Iterate over the members stored in the cache.

    Returns
    -------
    CacheIterator[hikari.guilds.Member]
        An async iterator of the members stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MemberCache.set_member"><code class="name flex">
<span>async def <span class="ident">set_member</span></span>(<span>self, member:Â guilds.Member, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a member to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code>hikari.guilds.Member</code></dt>
<dd>The member to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_member(self, member: guilds.Member, /) -&gt; None:
    &#34;&#34;&#34;Add a member to the cache.

    Parameters
    ----------
    member : hikari.guilds.Member
        The member to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.MessageCache"><code class="flex name class">
<span>class <span class="ident">MessageCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a message cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class MessageCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a message cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_messages(self) -&gt; None:
        &#34;&#34;&#34;Empty the messages cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a message from the cache.

        Parameters
        ----------
        message_id : hikari.snowflakes.Snowflakeish
            The ID of the message to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; messages.Message:
        &#34;&#34;&#34;Get a message from the cache.

        Parameters
        ----------
        message_id : hikari.snowflakes.Snowflakeish
            The ID of the message to get from the cache.

        Returns
        -------
        hikari.messages.Message
            The object of the message fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages(self) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_message(self, message: messages.Message, /) -&gt; None:
        &#34;&#34;&#34;Add a message to the cache.

        Parameters
        ----------
        message : hikari.messages.Message
            The message to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def update_message(self, message: messages.PartialMessage, /) -&gt; bool:
        &#34;&#34;&#34;Update a message in the cache using a partial message object.

        !!! note
            This won&#39;t be able to do anything unless an older version of the
            passed message is already cached.

        Parameters
        ----------
        message : messages.PartialMessage
            The partial object of the message to update in the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        # This is a special case method for handling the partial message updates we get
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.MessageCache" href="redis.html#sake.redis.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefMessageCache" href="#sake.traits.RefMessageCache">RefMessageCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.MessageCache.clear_messages"><code class="name flex">
<span>async def <span class="ident">clear_messages</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the messages cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_messages(self) -&gt; None:
    &#34;&#34;&#34;Empty the messages cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MessageCache.delete_message"><code class="name flex">
<span>async def <span class="ident">delete_message</span></span>(<span>self, message_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a message from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the message to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a message from the cache.

    Parameters
    ----------
    message_id : hikari.snowflakes.Snowflakeish
        The ID of the message to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MessageCache.get_message"><code class="name flex">
<span>async def <span class="ident">get_message</span></span>(<span>self, message_id:Â snowflakes.Snowflakeish, /) â€‘>Â messages.Message</span>
</code></dt>
<dd>
<div class="desc"><p>Get a message from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the message to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.messages.Message</code></dt>
<dd>The object of the message fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_message(self, message_id: snowflakes.Snowflakeish, /) -&gt; messages.Message:
    &#34;&#34;&#34;Get a message from the cache.

    Parameters
    ----------
    message_id : hikari.snowflakes.Snowflakeish
        The ID of the message to get from the cache.

    Returns
    -------
    hikari.messages.Message
        The object of the message fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MessageCache.iter_messages"><code class="name flex">
<span>def <span class="ident">iter_messages</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[messages.Message]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the messages stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.messages.Message]</code></dt>
<dd>An async iterator of the messages stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_messages(self) -&gt; CacheIterator[messages.Message]:
    &#34;&#34;&#34;Iterate over the messages stored in the cache.

    Returns
    -------
    CacheIterator[hikari.messages.Message]
        An async iterator of the messages stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MessageCache.set_message"><code class="name flex">
<span>async def <span class="ident">set_message</span></span>(<span>self, message:Â messages.Message, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a message to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>hikari.messages.Message</code></dt>
<dd>The message to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_message(self, message: messages.Message, /) -&gt; None:
    &#34;&#34;&#34;Add a message to the cache.

    Parameters
    ----------
    message : hikari.messages.Message
        The message to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.MessageCache.update_message"><code class="name flex">
<span>async def <span class="ident">update_message</span></span>(<span>self, message:Â messages.PartialMessage, /) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update a message in the cache using a partial message object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This won't be able to do anything unless an older version of the
passed message is already cached.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>messages.PartialMessage</code></dt>
<dd>The partial object of the message to update in the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def update_message(self, message: messages.PartialMessage, /) -&gt; bool:
    &#34;&#34;&#34;Update a message in the cache using a partial message object.

    !!! note
        This won&#39;t be able to do anything unless an older version of the
        passed message is already cached.

    Parameters
    ----------
    message : messages.PartialMessage
        The partial object of the message to update in the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    # This is a special case method for handling the partial message updates we get
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.PresenceCache"><code class="flex name class">
<span>class <span class="ident">PresenceCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a presence cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class PresenceCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a presence cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_presences(self) -&gt; None:
        &#34;&#34;&#34;Empty the presences cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_presence(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a presence from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached presence for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached presence for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_presence(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; presences.MemberPresence:
        &#34;&#34;&#34;Get a presence from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached presence for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached presence for.

        Returns
        -------
        hikari.presences.MemberPresence
            The object of the presence fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences(
        self,
    ) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        &#34;&#34;&#34;Add a presence to the cache.

        Parameters
        ----------
        presence : hikari.presences.MemberPresence
            The presence to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.PresenceCache" href="redis.html#sake.redis.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefPresenceCache" href="#sake.traits.RefPresenceCache">RefPresenceCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.PresenceCache.clear_presences"><code class="name flex">
<span>async def <span class="ident">clear_presences</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the presences cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_presences(self) -&gt; None:
    &#34;&#34;&#34;Empty the presences cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.PresenceCache.delete_presence"><code class="name flex">
<span>async def <span class="ident">delete_presence</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a presence from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove a cached presence for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove a cached presence for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_presence(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a presence from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove a cached presence for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove a cached presence for.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.PresenceCache.get_presence"><code class="name flex">
<span>async def <span class="ident">get_presence</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â presences.MemberPresence</span>
</code></dt>
<dd>
<div class="desc"><p>Get a presence from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get a cached presence for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to get a cached presence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.presences.MemberPresence</code></dt>
<dd>The object of the presence fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_presence(
    self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
) -&gt; presences.MemberPresence:
    &#34;&#34;&#34;Get a presence from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get a cached presence for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to get a cached presence for.

    Returns
    -------
    hikari.presences.MemberPresence
        The object of the presence fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.PresenceCache.iter_presences"><code class="name flex">
<span>def <span class="ident">iter_presences</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[presences.MemberPresence]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the presences stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.presences.MemberPresence]</code></dt>
<dd>An async iterator of the presences stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_presences(
    self,
) -&gt; CacheIterator[presences.MemberPresence]:
    &#34;&#34;&#34;Iterate over the presences stored in the cache.

    Returns
    -------
    CacheIterator[hikari.presences.MemberPresence]
        An async iterator of the presences stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.PresenceCache.set_presence"><code class="name flex">
<span>async def <span class="ident">set_presence</span></span>(<span>self, presence:Â presences.MemberPresence, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a presence to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>presence</code></strong> :&ensp;<code>hikari.presences.MemberPresence</code></dt>
<dd>The presence to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
    &#34;&#34;&#34;Add a presence to the cache.

    Parameters
    ----------
    presence : hikari.presences.MemberPresence
        The presence to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefCache"><code class="flex name class">
<span>class <span class="ident">RefCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol of a cache which implements all the defined reference resources.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefCache(
    Cache,
    RefGuildCache,
    RefEmojiCache,
    RefGuildChannelCache,
    RefIntegrationCache,
    RefInviteCache,
    RefMeCache,
    RefMemberCache,
    RefMessageCache,
    RefPresenceCache,
    RefRoleCache,
    RefUserCache,
    RefVoiceStateCache,
    typing.Protocol,
):
    &#34;&#34;&#34;Protocol of a cache which implements all the defined reference resources.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.RefEmojiCache" href="#sake.traits.RefEmojiCache">RefEmojiCache</a></li>
<li><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.RefGuildChannelCache" href="#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></li>
<li><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.RefIntegrationCache" href="#sake.traits.RefIntegrationCache">RefIntegrationCache</a></li>
<li><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.RefInviteCache" href="#sake.traits.RefInviteCache">RefInviteCache</a></li>
<li><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></li>
<li><a title="sake.traits.RefMemberCache" href="#sake.traits.RefMemberCache">RefMemberCache</a></li>
<li><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.RefMessageCache" href="#sake.traits.RefMessageCache">RefMessageCache</a></li>
<li><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.RefPresenceCache" href="#sake.traits.RefPresenceCache">RefPresenceCache</a></li>
<li><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.RefRoleCache" href="#sake.traits.RefRoleCache">RefRoleCache</a></li>
<li><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></li>
<li><a title="sake.traits.RefVoiceStateCache" href="#sake.traits.RefVoiceStateCache">RefVoiceStateCache</a></li>
<li><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Cache.clear_emojis" href="#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.traits.Cache.clear_guild_channels" href="#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.traits.Cache.clear_guilds" href="#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.traits.Cache.clear_integrations" href="#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.traits.Cache.clear_invites" href="#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.traits.Cache.clear_members" href="#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.traits.Cache.clear_messages" href="#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.traits.Cache.clear_presences" href="#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.traits.Cache.clear_roles" href="#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.traits.Cache.clear_users" href="#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.traits.Cache.clear_voice_states" href="#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.traits.Cache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Cache.delete_emoji" href="#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.traits.Cache.delete_guild" href="#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.traits.Cache.delete_guild_channel" href="#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.traits.Cache.delete_integration" href="#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.traits.Cache.delete_invite" href="#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.traits.Cache.delete_me" href="#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.traits.Cache.delete_member" href="#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.traits.Cache.delete_message" href="#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.traits.Cache.delete_presence" href="#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.traits.Cache.delete_role" href="#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.traits.Cache.delete_user" href="#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.traits.Cache.delete_voice_state" href="#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.traits.Cache.get_emoji" href="#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.traits.Cache.get_guild" href="#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.traits.Cache.get_guild_channel" href="#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.traits.Cache.get_integration" href="#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.traits.Cache.get_invite" href="#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.traits.Cache.get_me" href="#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.traits.Cache.get_member" href="#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.traits.Cache.get_message" href="#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.traits.Cache.get_presence" href="#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.traits.Cache.get_role" href="#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.traits.Cache.get_user" href="#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.traits.Cache.get_voice_state" href="#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.traits.Cache.iter_emojis" href="#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.traits.Cache.iter_guild_channels" href="#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.traits.Cache.iter_guilds" href="#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.traits.Cache.iter_integrations" href="#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.traits.Cache.iter_invites" href="#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.traits.Cache.iter_members" href="#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.traits.Cache.iter_messages" href="#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.traits.Cache.iter_presences" href="#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.traits.Cache.iter_roles" href="#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.traits.Cache.iter_users" href="#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.traits.Cache.iter_voice_states" href="#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.traits.Cache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Cache.set_emoji" href="#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
<li><code><a title="sake.traits.Cache.set_guild" href="#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
<li><code><a title="sake.traits.Cache.set_guild_channel" href="#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
<li><code><a title="sake.traits.Cache.set_integration" href="#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
<li><code><a title="sake.traits.Cache.set_invite" href="#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
<li><code><a title="sake.traits.Cache.set_me" href="#sake.traits.MeCache.set_me">set_me</a></code></li>
<li><code><a title="sake.traits.Cache.set_member" href="#sake.traits.MemberCache.set_member">set_member</a></code></li>
<li><code><a title="sake.traits.Cache.set_message" href="#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.traits.Cache.set_presence" href="#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
<li><code><a title="sake.traits.Cache.set_role" href="#sake.traits.RoleCache.set_role">set_role</a></code></li>
<li><code><a title="sake.traits.Cache.set_user" href="#sake.traits.UserCache.set_user">set_user</a></code></li>
<li><code><a title="sake.traits.Cache.set_voice_state" href="#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
<li><code><a title="sake.traits.Cache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Cache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Cache.update_message" href="#sake.traits.MessageCache.update_message">update_message</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefEmojiCache" href="#sake.traits.RefEmojiCache">RefEmojiCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefEmojiCache.clear_emojis_for_guild" href="#sake.traits.RefEmojiCache.clear_emojis_for_guild">clear_emojis_for_guild</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.iter_emojis_for_guild" href="#sake.traits.RefEmojiCache.iter_emojis_for_guild">iter_emojis_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefGuildChannelCache" href="#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild" href="#sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild" href="#sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild">iter_guild_channels_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefIntegrationCache" href="#sake.traits.RefIntegrationCache">RefIntegrationCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefIntegrationCache.clear_integrations_for_application" href="#sake.traits.RefIntegrationCache.clear_integrations_for_application">clear_integrations_for_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.clear_integrations_for_guild" href="#sake.traits.RefIntegrationCache.clear_integrations_for_guild">clear_integrations_for_guild</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.delete_integration_by_application" href="#sake.traits.RefIntegrationCache.delete_integration_by_application">delete_integration_by_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.get_integration_by_application" href="#sake.traits.RefIntegrationCache.get_integration_by_application">get_integration_by_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.iter_integrations_for_application" href="#sake.traits.RefIntegrationCache.iter_integrations_for_application">iter_integrations_for_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.iter_integrations_for_guild" href="#sake.traits.RefIntegrationCache.iter_integrations_for_guild">iter_integrations_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefInviteCache" href="#sake.traits.RefInviteCache">RefInviteCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefInviteCache.clear_invites_for_channel" href="#sake.traits.RefInviteCache.clear_invites_for_channel">clear_invites_for_channel</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.clear_invites_for_guild" href="#sake.traits.RefInviteCache.clear_invites_for_guild">clear_invites_for_guild</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.iter_invites_for_channel" href="#sake.traits.RefInviteCache.iter_invites_for_channel">iter_invites_for_channel</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.iter_invites_for_guild" href="#sake.traits.RefInviteCache.iter_invites_for_guild">iter_invites_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefMemberCache" href="#sake.traits.RefMemberCache">RefMemberCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefMemberCache.clear_members_for_guild" href="#sake.traits.RefMemberCache.clear_members_for_guild">clear_members_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.clear_members_for_user" href="#sake.traits.RefMemberCache.clear_members_for_user">clear_members_for_user</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.iter_members_for_guild" href="#sake.traits.RefMemberCache.iter_members_for_guild">iter_members_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.iter_members_for_user" href="#sake.traits.RefMemberCache.iter_members_for_user">iter_members_for_user</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefMessageCache" href="#sake.traits.RefMessageCache">RefMessageCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_author" href="#sake.traits.RefMessageCache.clear_messages_for_author">clear_messages_for_author</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_channel" href="#sake.traits.RefMessageCache.clear_messages_for_channel">clear_messages_for_channel</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_guild" href="#sake.traits.RefMessageCache.clear_messages_for_guild">clear_messages_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_message_for_channel" href="#sake.traits.RefMessageCache.iter_message_for_channel">iter_message_for_channel</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_messages_for_author" href="#sake.traits.RefMessageCache.iter_messages_for_author">iter_messages_for_author</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_messages_for_guild" href="#sake.traits.RefMessageCache.iter_messages_for_guild">iter_messages_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefPresenceCache" href="#sake.traits.RefPresenceCache">RefPresenceCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefPresenceCache.clear_presences_for_guild" href="#sake.traits.RefPresenceCache.clear_presences_for_guild">clear_presences_for_guild</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.clear_presences_for_user" href="#sake.traits.RefPresenceCache.clear_presences_for_user">clear_presences_for_user</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.iter_presences_for_guild" href="#sake.traits.RefPresenceCache.iter_presences_for_guild">iter_presences_for_guild</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.iter_presences_for_user" href="#sake.traits.RefPresenceCache.iter_presences_for_user">iter_presences_for_user</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefRoleCache" href="#sake.traits.RefRoleCache">RefRoleCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefRoleCache.clear_roles_for_guild" href="#sake.traits.RefRoleCache.clear_roles_for_guild">clear_roles_for_guild</a></code></li>
<li><code><a title="sake.traits.RefRoleCache.iter_roles_for_guild" href="#sake.traits.RefRoleCache.iter_roles_for_guild">iter_roles_for_guild</a></code></li>
</ul>
</li>
<li><code><b><a title="sake.traits.RefVoiceStateCache" href="#sake.traits.RefVoiceStateCache">RefVoiceStateCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RefVoiceStateCache.clear_voice_states_for_channel" href="#sake.traits.RefVoiceStateCache.clear_voice_states_for_channel">clear_voice_states_for_channel</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.clear_voice_states_for_guild" href="#sake.traits.RefVoiceStateCache.clear_voice_states_for_guild">clear_voice_states_for_guild</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.iter_voice_states_for_channel" href="#sake.traits.RefVoiceStateCache.iter_voice_states_for_channel">iter_voice_states_for_channel</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.iter_voice_states_for_guild" href="#sake.traits.RefVoiceStateCache.iter_voice_states_for_guild">iter_voice_states_for_guild</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefEmojiCache"><code class="flex name class">
<span>class <span class="ident">RefEmojiCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial emoji cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefEmojiCache(EmojiCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial emoji cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove emojis belonging to a specific guild from the cache.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the emojis cached for.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Iterate over the emojis stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the emojis cached for.

        Returns
        -------
        CacheIterator[hikari.emojis.KnownCustomEmoji]
            An async iterator of the emojis stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.EmojiCache" href="redis.html#sake.redis.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefEmojiCache.clear_emojis_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_emojis_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove emojis belonging to a specific guild from the cache.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the emojis cached for.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove emojis belonging to a specific guild from the cache.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the emojis cached for.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefEmojiCache.iter_emojis_for_guild"><code class="name flex">
<span>def <span class="ident">iter_emojis_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[emojis.KnownCustomEmoji]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the emojis stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the emojis cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.emojis.KnownCustomEmoji]</code></dt>
<dd>An async iterator of the emojis stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_emojis_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[emojis.KnownCustomEmoji]:
    &#34;&#34;&#34;Iterate over the emojis stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the emojis cached for.

    Returns
    -------
    CacheIterator[hikari.emojis.KnownCustomEmoji]
        An async iterator of the emojis stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.EmojiCache.clear_emojis" href="#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.EmojiCache.delete_emoji" href="#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.get_emoji" href="#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.iter_emojis" href="#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.EmojiCache.set_emoji" href="#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.EmojiCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefGuildChannelCache"><code class="flex name class">
<span>class <span class="ident">RefGuildChannelCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial guild channel cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefGuildChannelCache(GuildChannelCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial guild channel cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_guild_channels_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the guild channel cache store for the specified guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached channels for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[channels.GuildChannel]:
        &#34;&#34;&#34;Iterate over the guild channels stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the guild channels cached for it.

        Returns
        -------
        CacheIterator[hikari.channels.GuildChannel]
            An async iterator of the guild channels stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.GuildChannelCache" href="redis.html#sake.redis.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_guild_channels_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the guild channel cache store for the specified guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the cached channels for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_guild_channels_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the guild channel cache store for the specified guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the cached channels for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild"><code class="name flex">
<span>def <span class="ident">iter_guild_channels_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[channels.GuildChannel]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the guild channels stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the guild channels cached for it.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.channels.GuildChannel]</code></dt>
<dd>An async iterator of the guild channels stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_guild_channels_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /
) -&gt; CacheIterator[channels.GuildChannel]:
    &#34;&#34;&#34;Iterate over the guild channels stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the guild channels cached for it.

    Returns
    -------
    CacheIterator[hikari.channels.GuildChannel]
        An async iterator of the guild channels stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.GuildChannelCache.clear_guild_channels" href="#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.delete_guild_channel" href="#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.get_guild_channel" href="#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.iter_guild_channels" href="#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.set_guild_channel" href="#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefIntegrationCache"><code class="flex name class">
<span>class <span class="ident">RefIntegrationCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial invite cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefIntegrationCache(IntegrationCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial invite cache.&#34;&#34;&#34;

    async def clear_integrations_for_application(self, application_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the integrations cached for an application.

        Parameters
        ----------
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to remove cached integrations for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the integrations cached for a guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove cached integrations for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_integration_by_application(
        self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
    ) -&gt; None:
        &#34;&#34;&#34;Remove an integration channel from the cache by the ID of it&#39;s application.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove an integration for.
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to remove an integration for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_integration_by_application(
        self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
    ) -&gt; guilds.Integration:
        &#34;&#34;&#34;Get an integration from the cache by the ID of it&#39;s application.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get an integration for.
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to get an integration for.

        Returns
        -------
        hikari.guilds.Integration
            The object of the integration fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations_for_application(
        self, application_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific application.

        Parameters
        ----------
        application_id : hikari.snowflakes.Snowflakeish
            The ID of the application to iterate over the cached integrations for.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache for the
            specified application.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Integration]:
        &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the cached integrations for.

        Returns
        -------
        CacheIterator[hikari.guilds.Integration]
            An async iterator of the integrations stored in the cache for the
            specified application.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefIntegrationCache.clear_integrations_for_application"><code class="name flex">
<span>async def <span class="ident">clear_integrations_for_application</span></span>(<span>self, application_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the integrations cached for an application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the application to remove cached integrations for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_integrations_for_application(self, application_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the integrations cached for an application.

    Parameters
    ----------
    application_id : hikari.snowflakes.Snowflakeish
        The ID of the application to remove cached integrations for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefIntegrationCache.clear_integrations_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_integrations_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the integrations cached for a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove cached integrations for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the integrations cached for a guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove cached integrations for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefIntegrationCache.delete_integration_by_application"><code class="name flex">
<span>async def <span class="ident">delete_integration_by_application</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, application_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an integration channel from the cache by the ID of it's application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove an integration for.</dd>
<dt><strong><code>application_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the application to remove an integration for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_integration_by_application(
    self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
) -&gt; None:
    &#34;&#34;&#34;Remove an integration channel from the cache by the ID of it&#39;s application.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove an integration for.
    application_id : hikari.snowflakes.Snowflakeish
        The ID of the application to remove an integration for.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefIntegrationCache.get_integration_by_application"><code class="name flex">
<span>async def <span class="ident">get_integration_by_application</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, application_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.Integration</span>
</code></dt>
<dd>
<div class="desc"><p>Get an integration from the cache by the ID of it's application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get an integration for.</dd>
<dt><strong><code>application_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the application to get an integration for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.Integration</code></dt>
<dd>The object of the integration fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_integration_by_application(
    self, guild_id: snowflakes.Snowflakeish, application_id: snowflakes.Snowflakeish, /
) -&gt; guilds.Integration:
    &#34;&#34;&#34;Get an integration from the cache by the ID of it&#39;s application.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get an integration for.
    application_id : hikari.snowflakes.Snowflakeish
        The ID of the application to get an integration for.

    Returns
    -------
    hikari.guilds.Integration
        The object of the integration fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefIntegrationCache.iter_integrations_for_application"><code class="name flex">
<span>def <span class="ident">iter_integrations_for_application</span></span>(<span>self, application_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Integration]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the integrations stored in the cache for a specific application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the application to iterate over the cached integrations for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Integration]</code></dt>
<dd>An async iterator of the integrations stored in the cache for the
specified application.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_integrations_for_application(
    self, application_id: snowflakes.Snowflakeish, /
) -&gt; CacheIterator[guilds.Integration]:
    &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific application.

    Parameters
    ----------
    application_id : hikari.snowflakes.Snowflakeish
        The ID of the application to iterate over the cached integrations for.

    Returns
    -------
    CacheIterator[hikari.guilds.Integration]
        An async iterator of the integrations stored in the cache for the
        specified application.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefIntegrationCache.iter_integrations_for_guild"><code class="name flex">
<span>def <span class="ident">iter_integrations_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Integration]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the integrations stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the cached integrations for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Integration]</code></dt>
<dd>An async iterator of the integrations stored in the cache for the
specified application.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_integrations_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Integration]:
    &#34;&#34;&#34;Iterate over the integrations stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the cached integrations for.

    Returns
    -------
    CacheIterator[hikari.guilds.Integration]
        An async iterator of the integrations stored in the cache for the
        specified application.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.IntegrationCache.clear_integrations" href="#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.delete_integration" href="#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.get_integration" href="#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.iter_integrations" href="#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.set_integration" href="#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefInviteCache"><code class="flex name class">
<span>class <span class="ident">RefInviteCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial invite cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefInviteCache(InviteCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial invite cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_invites_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove invites cached for a specific channel..

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the invites cached for it.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove invites cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the invites cached for it.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites_for_channel(
        self, channel_id: snowflakes.Snowflakeish, /
    ) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the invites cached for.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the invites cached for.

        Returns
        -------
        CacheIterator[hikari.invites.InviteWithMetadata]
            An async iterator of the invites stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefInviteCache.clear_invites_for_channel"><code class="name flex">
<span>async def <span class="ident">clear_invites_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove invites cached for a specific channel..</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to remove the invites cached for it.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_invites_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove invites cached for a specific channel..

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to remove the invites cached for it.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefInviteCache.clear_invites_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_invites_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove invites cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the invites cached for it.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove invites cached for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the invites cached for it.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefInviteCache.iter_invites_for_channel"><code class="name flex">
<span>def <span class="ident">iter_invites_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[invites.InviteWithMetadata]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the invites stored in the cache for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to iterate over the invites cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.invites.InviteWithMetadata]</code></dt>
<dd>An async iterator of the invites stored in the cache for the
specified channel.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_invites_for_channel(
    self, channel_id: snowflakes.Snowflakeish, /
) -&gt; CacheIterator[invites.InviteWithMetadata]:
    &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific channel.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to iterate over the invites cached for.

    Returns
    -------
    CacheIterator[hikari.invites.InviteWithMetadata]
        An async iterator of the invites stored in the cache for the
        specified channel.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefInviteCache.iter_invites_for_guild"><code class="name flex">
<span>def <span class="ident">iter_invites_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[invites.InviteWithMetadata]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the invites stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the invites cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.invites.InviteWithMetadata]</code></dt>
<dd>An async iterator of the invites stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_invites_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[invites.InviteWithMetadata]:
    &#34;&#34;&#34;Iterate over the invites stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the invites cached for.

    Returns
    -------
    CacheIterator[hikari.invites.InviteWithMetadata]
        An async iterator of the invites stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.InviteCache.clear_invites" href="#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.InviteCache.delete_invite" href="#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.get_invite" href="#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.iter_invites" href="#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.InviteCache.set_invite" href="#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.InviteCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefMemberCache"><code class="flex name class">
<span>class <span class="ident">RefMemberCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial member cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefMemberCache(MemberCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial member cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the members cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached members for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the members cached for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the cached members for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the members cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
        &#34;&#34;&#34;Iterate over the members stored in the cache for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the user cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Member]
            An async iterator of the members stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefMemberCache.clear_members_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_members_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the members cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the cached members for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the members cached for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the cached members for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMemberCache.clear_members_for_user"><code class="name flex">
<span>async def <span class="ident">clear_members_for_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the members cached for a specific user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove the cached members for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the members cached for a specific user.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove the cached members for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMemberCache.iter_members_for_guild"><code class="name flex">
<span>def <span class="ident">iter_members_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Member]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the members stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get the members cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Member]</code></dt>
<dd>An async iterator of the members stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_members_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
    &#34;&#34;&#34;Iterate over the members stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get the members cached for.

    Returns
    -------
    CacheIterator[hikari.guilds.Member]
        An async iterator of the members stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMemberCache.iter_members_for_user"><code class="name flex">
<span>def <span class="ident">iter_members_for_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Member]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the members stored in the cache for a specific user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get the user cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Member]</code></dt>
<dd>An async iterator of the members stored in the cache for the
specified user.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_members_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Member]:
    &#34;&#34;&#34;Iterate over the members stored in the cache for a specific user.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get the user cached for.

    Returns
    -------
    CacheIterator[hikari.guilds.Member]
        An async iterator of the members stored in the cache for the
        specified user.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MemberCache.clear_members" href="#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.MemberCache.delete_member" href="#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.get_member" href="#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.iter_members" href="#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.MemberCache.set_member" href="#sake.traits.MemberCache.set_member">set_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.MemberCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefMessageCache"><code class="flex name class">
<span>class <span class="ident">RefMessageCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial message cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefMessageCache(MessageCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial message cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific author.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_messages_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the messages cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the messages cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific author.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_message_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
        &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the messages cached for them.

        Returns
        -------
        CacheIterator[hikari.messages.Message]
            An async iterator of the messages stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefMessageCache.clear_messages_for_author"><code class="name flex">
<span>async def <span class="ident">clear_messages_for_author</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the messages cached for a specific author.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove the messages cached for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the messages cached for a specific author.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove the messages cached for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMessageCache.clear_messages_for_channel"><code class="name flex">
<span>async def <span class="ident">clear_messages_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the messages cached for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to remove the messages cached for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_messages_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the messages cached for a specific channel.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to remove the messages cached for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMessageCache.clear_messages_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_messages_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the messages cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the messages cached for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the messages cached for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the messages cached for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMessageCache.iter_message_for_channel"><code class="name flex">
<span>def <span class="ident">iter_message_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[messages.Message]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the messages stored in the cache for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to iterate over the messages cached for them.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.messages.Message]</code></dt>
<dd>An async iterator of the messages stored in the cache for the
specified channel.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_message_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
    &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific channel.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to iterate over the messages cached for them.

    Returns
    -------
    CacheIterator[hikari.messages.Message]
        An async iterator of the messages stored in the cache for the
        specified channel.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMessageCache.iter_messages_for_author"><code class="name flex">
<span>def <span class="ident">iter_messages_for_author</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[messages.Message]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the messages stored in the cache for a specific author.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to iterate over the messages cached for them.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.messages.Message]</code></dt>
<dd>An async iterator of the messages stored in the cache for the
specified user.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_messages_for_author(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
    &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific author.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to iterate over the messages cached for them.

    Returns
    -------
    CacheIterator[hikari.messages.Message]
        An async iterator of the messages stored in the cache for the
        specified user.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefMessageCache.iter_messages_for_guild"><code class="name flex">
<span>def <span class="ident">iter_messages_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[messages.Message]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the messages stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the messages cached for them.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.messages.Message]</code></dt>
<dd>An async iterator of the messages stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_messages_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[messages.Message]:
    &#34;&#34;&#34;Iterate over the messages stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the messages cached for them.

    Returns
    -------
    CacheIterator[hikari.messages.Message]
        An async iterator of the messages stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.MessageCache.clear_messages" href="#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.MessageCache.delete_message" href="#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.get_message" href="#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.iter_messages" href="#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.MessageCache.set_message" href="#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.MessageCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
<li><code><a title="sake.traits.MessageCache.update_message" href="#sake.traits.MessageCache.update_message">update_message</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefPresenceCache"><code class="flex name class">
<span>class <span class="ident">RefPresenceCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial presence cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefPresenceCache(PresenceCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial presence cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the presences cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached presences for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the presences cached for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove the cached presences for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the cached presences for.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
        &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific user.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to iterate over the cached presences for.

        Returns
        -------
        CacheIterator[hikari.presences.MemberPresence]
            An async iterator of the presences stored in the cache for the
            specified user.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefPresenceCache.clear_presences_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_presences_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the presences cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the cached presences for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the presences cached for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the cached presences for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefPresenceCache.clear_presences_for_user"><code class="name flex">
<span>async def <span class="ident">clear_presences_for_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the presences cached for a specific user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove the cached presences for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the presences cached for a specific user.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove the cached presences for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefPresenceCache.iter_presences_for_guild"><code class="name flex">
<span>def <span class="ident">iter_presences_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[presences.MemberPresence]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the presences stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the cached presences for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.presences.MemberPresence]</code></dt>
<dd>An async iterator of the presences stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_presences_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
    &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the cached presences for.

    Returns
    -------
    CacheIterator[hikari.presences.MemberPresence]
        An async iterator of the presences stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefPresenceCache.iter_presences_for_user"><code class="name flex">
<span>def <span class="ident">iter_presences_for_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[presences.MemberPresence]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the presences stored in the cache for a specific user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to iterate over the cached presences for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.presences.MemberPresence]</code></dt>
<dd>An async iterator of the presences stored in the cache for the
specified user.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_presences_for_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[presences.MemberPresence]:
    &#34;&#34;&#34;Iterate over the presences stored in the cache for a specific user.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to iterate over the cached presences for.

    Returns
    -------
    CacheIterator[hikari.presences.MemberPresence]
        An async iterator of the presences stored in the cache for the
        specified user.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.PresenceCache.clear_presences" href="#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.PresenceCache.delete_presence" href="#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.get_presence" href="#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.iter_presences" href="#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.PresenceCache.set_presence" href="#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.PresenceCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefRoleCache"><code class="flex name class">
<span>class <span class="ident">RefRoleCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial role cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefRoleCache(RoleCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial role cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the roles cached for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the cached roles for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Role]:
        &#34;&#34;&#34;Iterate over the roles stored in the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get the roles cached for.

        Returns
        -------
        CacheIterator[hikari.guilds.Role]
            An async iterator of the roles stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefRoleCache.clear_roles_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_roles_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the roles cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the cached roles for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the roles cached for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the cached roles for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefRoleCache.iter_roles_for_guild"><code class="name flex">
<span>def <span class="ident">iter_roles_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Role]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the roles stored in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get the roles cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Role]</code></dt>
<dd>An async iterator of the roles stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_roles_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[guilds.Role]:
    &#34;&#34;&#34;Iterate over the roles stored in the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get the roles cached for.

    Returns
    -------
    CacheIterator[hikari.guilds.Role]
        An async iterator of the roles stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.RoleCache.clear_roles" href="#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.RoleCache.delete_role" href="#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.get_role" href="#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.iter_roles" href="#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.RoleCache.set_role" href="#sake.traits.RoleCache.set_role">set_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.RoleCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.RefVoiceStateCache"><code class="flex name class">
<span>class <span class="ident">RefVoiceStateCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a referencial voice state cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RefVoiceStateCache(VoiceStateCache, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a referencial voice state cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()  # TODO: for user?

    async def clear_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the voice states cached for a specified channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to remove the voice states cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove the voice states cached for a specified guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove the voice states cached for.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific channel.

        Parameters
        ----------
        channel_id : hikari.snowflakes.Snowflakeish
            The ID of the channel to iterate over the voice states cached for.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache for the
            specified channel.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific guild.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to iterate over the voice states cached for.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache for the
            specified guild.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RefVoiceStateCache.clear_voice_states_for_channel"><code class="name flex">
<span>async def <span class="ident">clear_voice_states_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the voice states cached for a specified channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to remove the voice states cached for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the voice states cached for a specified channel.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to remove the voice states cached for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefVoiceStateCache.clear_voice_states_for_guild"><code class="name flex">
<span>async def <span class="ident">clear_voice_states_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the voice states cached for a specified guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove the voice states cached for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove the voice states cached for a specified guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove the voice states cached for.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefVoiceStateCache.iter_voice_states_for_channel"><code class="name flex">
<span>def <span class="ident">iter_voice_states_for_channel</span></span>(<span>self, channel_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[voices.VoiceState]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the voice states stored in the cache for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the channel to iterate over the voice states cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.voices.VoiceState]</code></dt>
<dd>An async iterator of the voice states stored in the cache for the
specified channel.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_voice_states_for_channel(self, channel_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
    &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific channel.

    Parameters
    ----------
    channel_id : hikari.snowflakes.Snowflakeish
        The ID of the channel to iterate over the voice states cached for.

    Returns
    -------
    CacheIterator[hikari.voices.VoiceState]
        An async iterator of the voice states stored in the cache for the
        specified channel.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RefVoiceStateCache.iter_voice_states_for_guild"><code class="name flex">
<span>def <span class="ident">iter_voice_states_for_guild</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, /) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[voices.VoiceState]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the voice states stored in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to iterate over the voice states cached for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.voices.VoiceState]</code></dt>
<dd>An async iterator of the voice states stored in the cache for the
specified guild.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_voice_states_for_guild(self, guild_id: snowflakes.Snowflakeish, /) -&gt; CacheIterator[voices.VoiceState]:
    &#34;&#34;&#34;Iterate over the voice states stored in the cache for a specific guild.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to iterate over the voice states cached for.

    Returns
    -------
    CacheIterator[hikari.voices.VoiceState]
        An async iterator of the voice states stored in the cache for the
        specified guild.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.VoiceStateCache.clear_voice_states" href="#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.delete_voice_state" href="#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.get_voice_state" href="#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.iter_voice_states" href="#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.set_voice_state" href="#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.Resource"><code class="flex name class">
<span>class <span class="ident">Resource</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The basic interface which all cache resources should implement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class Resource(typing.Protocol):
    &#34;&#34;&#34;The basic interface which all cache resources should implement.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def subscribe_listeners(self) -&gt; None:
        &#34;&#34;&#34;Register this resource&#39;s internal listener to a dispatcher aware app.

        !!! note
            Dependent on the implementation, this may be called by
            `Resource.open` and may raise a `builtins.TypeError`if called
            when this resource&#39;s listeners have already been registered.

        !!! note
            If the event dispatcher isn&#39;t provided during initialisation then
            this method will do nothing.
        &#34;&#34;&#34;
        raise NotImplementedError

    def unsubscribe_listeners(self) -&gt; None:
        &#34;&#34;&#34;Unregister this resource&#39;s internal listener to a dispatcher aware app.

        !!! note
            Dependent on the implementation, this may be called by
            `Resource.close` and may raise a `builtins.TypeError`if called
            when this resource&#39;s listeners haven&#39;t been registered yet.

        !!! note
            If the event dispatcher isn&#39;t provided during initialisation then
            this method will do nothing.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def open(self) -&gt; None:
        &#34;&#34;&#34;Startup the resource(s) and allow them to connect to their relevant backend(s).

        !!! note
            This should implicitly call `Resource.subscribe_listeners`.

        !!! note
            This should pass without raising if called on an already opened
            resource.
        &#34;&#34;&#34;
        raise NotImplementedError  # TODO: connection errors.

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the resource(s) and allow them to disconnect from their relevant backend(s).

        !!! note
            This should implicitly call `Resource.unsubscribe_listeners`.

        !!! note
            This should pass without raising if called on an already closed
            resource.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.ResourceClient" href="redis.html#sake.redis.ResourceClient">ResourceClient</a></li>
<li><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></li>
<li><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></li>
<li><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></li>
<li><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></li>
<li><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></li>
<li><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></li>
<li><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></li>
<li><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></li>
<li><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></li>
<li><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></li>
<li><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.Resource.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close the resource(s) and allow them to disconnect from their relevant backend(s).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should implicitly call <code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">Resource.unsubscribe_listeners()</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should pass without raising if called on an already closed
resource.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the resource(s) and allow them to disconnect from their relevant backend(s).

    !!! note
        This should implicitly call `Resource.unsubscribe_listeners`.

    !!! note
        This should pass without raising if called on an already closed
        resource.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.Resource.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Startup the resource(s) and allow them to connect to their relevant backend(s).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should implicitly call <code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">Resource.subscribe_listeners()</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should pass without raising if called on an already opened
resource.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;Startup the resource(s) and allow them to connect to their relevant backend(s).

    !!! note
        This should implicitly call `Resource.subscribe_listeners`.

    !!! note
        This should pass without raising if called on an already opened
        resource.
    &#34;&#34;&#34;
    raise NotImplementedError  # TODO: connection errors.</code></pre>
</details>
</dd>
<dt id="sake.traits.Resource.subscribe_listeners"><code class="name flex">
<span>def <span class="ident">subscribe_listeners</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Register this resource's internal listener to a dispatcher aware app.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dependent on the implementation, this may be called by
<code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">Resource.open()</a></code> and may raise a <code>builtins.TypeError</code>if called
when this resource's listeners have already been registered.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the event dispatcher isn't provided during initialisation then
this method will do nothing.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_listeners(self) -&gt; None:
    &#34;&#34;&#34;Register this resource&#39;s internal listener to a dispatcher aware app.

    !!! note
        Dependent on the implementation, this may be called by
        `Resource.open` and may raise a `builtins.TypeError`if called
        when this resource&#39;s listeners have already been registered.

    !!! note
        If the event dispatcher isn&#39;t provided during initialisation then
        this method will do nothing.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.Resource.unsubscribe_listeners"><code class="name flex">
<span>def <span class="ident">unsubscribe_listeners</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister this resource's internal listener to a dispatcher aware app.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dependent on the implementation, this may be called by
<code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">Resource.close()</a></code> and may raise a <code>builtins.TypeError</code>if called
when this resource's listeners haven't been registered yet.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the event dispatcher isn't provided during initialisation then
this method will do nothing.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsubscribe_listeners(self) -&gt; None:
    &#34;&#34;&#34;Unregister this resource&#39;s internal listener to a dispatcher aware app.

    !!! note
        Dependent on the implementation, this may be called by
        `Resource.close` and may raise a `builtins.TypeError`if called
        when this resource&#39;s listeners haven&#39;t been registered yet.

    !!! note
        If the event dispatcher isn&#39;t provided during initialisation then
        this method will do nothing.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sake.traits.RoleCache"><code class="flex name class">
<span>class <span class="ident">RoleCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a role cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class RoleCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a role cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_roles(self) -&gt; None:
        &#34;&#34;&#34;Empty the roles cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a role from the cache.

        Parameters
        ----------
        role_id : hikari.snowflakes.Snowflakeish
            The ID of the role to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; guilds.Role:
        &#34;&#34;&#34;Get a role from the cache.

        Parameters
        ----------
        role_id : hikari.snowflakes.Snowflakeish
            The ID of the role to get from the cache.

        Returns
        -------
        hikari.guilds.Role
            The object of the role fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_roles(self) -&gt; CacheIterator[guilds.Role]:
        &#34;&#34;&#34;Iterate over the roles stored in the cache.

        Returns
        -------
        CacheIterator[hikari.guilds.Role]
            An async iterator of the roles stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_role(self, role: guilds.Role, /) -&gt; None:
        &#34;&#34;&#34;Add a role to the cache.

        Parameters
        ----------
        role : hikari.guilds.Role
            The role to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.RoleCache" href="redis.html#sake.redis.RoleCache">RoleCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefRoleCache" href="#sake.traits.RefRoleCache">RefRoleCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.RoleCache.clear_roles"><code class="name flex">
<span>async def <span class="ident">clear_roles</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the roles cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_roles(self) -&gt; None:
    &#34;&#34;&#34;Empty the roles cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RoleCache.delete_role"><code class="name flex">
<span>async def <span class="ident">delete_role</span></span>(<span>self, role_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a role from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the role to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a role from the cache.

    Parameters
    ----------
    role_id : hikari.snowflakes.Snowflakeish
        The ID of the role to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RoleCache.get_role"><code class="name flex">
<span>async def <span class="ident">get_role</span></span>(<span>self, role_id:Â snowflakes.Snowflakeish, /) â€‘>Â guilds.Role</span>
</code></dt>
<dd>
<div class="desc"><p>Get a role from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the role to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.guilds.Role</code></dt>
<dd>The object of the role fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_role(self, role_id: snowflakes.Snowflakeish, /) -&gt; guilds.Role:
    &#34;&#34;&#34;Get a role from the cache.

    Parameters
    ----------
    role_id : hikari.snowflakes.Snowflakeish
        The ID of the role to get from the cache.

    Returns
    -------
    hikari.guilds.Role
        The object of the role fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RoleCache.iter_roles"><code class="name flex">
<span>def <span class="ident">iter_roles</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[guilds.Role]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the roles stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.guilds.Role]</code></dt>
<dd>An async iterator of the roles stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_roles(self) -&gt; CacheIterator[guilds.Role]:
    &#34;&#34;&#34;Iterate over the roles stored in the cache.

    Returns
    -------
    CacheIterator[hikari.guilds.Role]
        An async iterator of the roles stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.RoleCache.set_role"><code class="name flex">
<span>async def <span class="ident">set_role</span></span>(<span>self, role:Â guilds.Role, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a role to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>hikari.guilds.Role</code></dt>
<dd>The role to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_role(self, role: guilds.Role, /) -&gt; None:
    &#34;&#34;&#34;Add a role to the cache.

    Parameters
    ----------
    role : hikari.guilds.Role
        The role to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.UserCache"><code class="flex name class">
<span>class <span class="ident">RefUserCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a cache implementation which supports a user cache.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike other resources, user doesn't have any events which
directly update it and may only be updated through event
listeners when resources which reference it are also included.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class UserCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a cache implementation which supports a user cache.

    !!! note
        Unlike other resources, user doesn&#39;t have any events which
        directly update it and may only be updated through event
        listeners when resources which reference it are also included.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_users(self) -&gt; None:  # TODO: cascade
        &#34;&#34;&#34;Empty the users cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
        &#34;&#34;&#34;Get a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get from the cache.

        Returns
        -------
        hikari.users.User
            The object of the user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_users(self) -&gt; CacheIterator[users.User]:
        &#34;&#34;&#34;Iterate over the users stored in the cache.

        Returns
        -------
        CacheIterator[hikari.users.User]
            An async iterator of the users stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_user(self, user: users.User, /) -&gt; None:
        &#34;&#34;&#34;Add a user to the cache.

        Parameters
        ----------
        user : hikari.users.User
            The user to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.UserCache" href="redis.html#sake.redis.UserCache">UserCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.UserCache.clear_users"><code class="name flex">
<span>async def <span class="ident">clear_users</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the users cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_users(self) -&gt; None:  # TODO: cascade
    &#34;&#34;&#34;Empty the users cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.delete_user"><code class="name flex">
<span>async def <span class="ident">delete_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a user from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a user from the cache.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.get_user"><code class="name flex">
<span>async def <span class="ident">get_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â users.User</span>
</code></dt>
<dd>
<div class="desc"><p>Get a user from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.users.User</code></dt>
<dd>The object of the user fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
    &#34;&#34;&#34;Get a user from the cache.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to get from the cache.

    Returns
    -------
    hikari.users.User
        The object of the user fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.iter_users"><code class="name flex">
<span>def <span class="ident">iter_users</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[users.User]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the users stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.users.User]</code></dt>
<dd>An async iterator of the users stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_users(self) -&gt; CacheIterator[users.User]:
    &#34;&#34;&#34;Iterate over the users stored in the cache.

    Returns
    -------
    CacheIterator[hikari.users.User]
        An async iterator of the users stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.set_user"><code class="name flex">
<span>async def <span class="ident">set_user</span></span>(<span>self, user:Â users.User, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a user to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>hikari.users.User</code></dt>
<dd>The user to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_user(self, user: users.User, /) -&gt; None:
    &#34;&#34;&#34;Add a user to the cache.

    Parameters
    ----------
    user : hikari.users.User
        The user to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sake.traits.UserCache"><code class="flex name class">
<span>class <span class="ident">UserCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a cache implementation which supports a user cache.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike other resources, user doesn't have any events which
directly update it and may only be updated through event
listeners when resources which reference it are also included.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class UserCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a cache implementation which supports a user cache.

    !!! note
        Unlike other resources, user doesn&#39;t have any events which
        directly update it and may only be updated through event
        listeners when resources which reference it are also included.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_users(self) -&gt; None:  # TODO: cascade
        &#34;&#34;&#34;Empty the users cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove from the cache.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
        &#34;&#34;&#34;Get a user from the cache.

        Parameters
        ----------
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get from the cache.

        Returns
        -------
        hikari.users.User
            The object of the user fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_users(self) -&gt; CacheIterator[users.User]:
        &#34;&#34;&#34;Iterate over the users stored in the cache.

        Returns
        -------
        CacheIterator[hikari.users.User]
            An async iterator of the users stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_user(self, user: users.User, /) -&gt; None:
        &#34;&#34;&#34;Add a user to the cache.

        Parameters
        ----------
        user : hikari.users.User
            The user to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.UserCache" href="redis.html#sake.redis.UserCache">UserCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.UserCache.clear_users"><code class="name flex">
<span>async def <span class="ident">clear_users</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the users cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_users(self) -&gt; None:  # TODO: cascade
    &#34;&#34;&#34;Empty the users cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.delete_user"><code class="name flex">
<span>async def <span class="ident">delete_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a user from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove from the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a user from the cache.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove from the cache.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.get_user"><code class="name flex">
<span>async def <span class="ident">get_user</span></span>(<span>self, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â users.User</span>
</code></dt>
<dd>
<div class="desc"><p>Get a user from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.users.User</code></dt>
<dd>The object of the user fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_user(self, user_id: snowflakes.Snowflakeish, /) -&gt; users.User:
    &#34;&#34;&#34;Get a user from the cache.

    Parameters
    ----------
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to get from the cache.

    Returns
    -------
    hikari.users.User
        The object of the user fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.iter_users"><code class="name flex">
<span>def <span class="ident">iter_users</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[users.User]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the users stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.users.User]</code></dt>
<dd>An async iterator of the users stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_users(self) -&gt; CacheIterator[users.User]:
    &#34;&#34;&#34;Iterate over the users stored in the cache.

    Returns
    -------
    CacheIterator[hikari.users.User]
        An async iterator of the users stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.UserCache.set_user"><code class="name flex">
<span>async def <span class="ident">set_user</span></span>(<span>self, user:Â users.User, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a user to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>hikari.users.User</code></dt>
<dd>The user to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_user(self, user: users.User, /) -&gt; None:
    &#34;&#34;&#34;Add a user to the cache.

    Parameters
    ----------
    user : hikari.users.User
        The user to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sake.traits.VoiceStateCache"><code class="flex name class">
<span>class <span class="ident">VoiceStateCache</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The traits of a implementation which supports a voice state cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@typing.runtime_checkable
class VoiceStateCache(Resource, typing.Protocol):
    &#34;&#34;&#34;The traits of a implementation which supports a voice state cache.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    async def clear_voice_states(self) -&gt; None:
        &#34;&#34;&#34;Empty the voice states cache store.

        !!! note
            There is no guarantee that this operation will be complete before
            the returned coroutine finishes.

        Raises
        ------
        sake.errors.BackendError
            Raised when this call failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def delete_voice_state(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
        &#34;&#34;&#34;Remove a voice state from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to remove a cached voice state for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to remove a cached voice state for.

        !!! note
            Delete methods do not raise `sake.errors.EntryNotFound` when the
            targeted entity doesn&#39;t exist.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def get_voice_state(
        self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
    ) -&gt; voices.VoiceState:
        &#34;&#34;&#34;Get a voice state from the cache.

        Parameters
        ----------
        guild_id : hikari.snowflakes.Snowflakeish
            The ID of the guild to get a cached voice state for.
        user_id : hikari.snowflakes.Snowflakeish
            The ID of the user to get a cached voice state for.

        Returns
        -------
        hikari.voices.VoiceState
            The object of the voice state fetched from the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.EntryNotFound
            Raised when the targeted entity wasn&#39;t found.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    def iter_voice_states(self) -&gt; CacheIterator[voices.VoiceState]:
        &#34;&#34;&#34;Iterate over the voice states stored in the cache.

        Returns
        -------
        CacheIterator[hikari.voices.VoiceState]
            An async iterator of the voice states stored in the cache.

        !!! note
            Errors won&#39;t be raised by the initial call to this method but rather
            while iterating over the returned asynchronous iterator.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s backend.
            This may be a sign of underlying network or database issues.
        sake.errors.InvalidDataFound
            Raised when the data retrieved from the backend datastore was
            either invalid for this implementation or corrupt.
            This may be a sign of multiple sake versions or implementations
            being used with the same backend store.
        &#34;&#34;&#34;
        raise NotImplementedError

    async def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        &#34;&#34;&#34;Add a voice state to the cache.

        Parameters
        ----------
        voice_state : hikari.voices.VoiceState
            The voice state to add to the cache.

        Raises
        ------
        sake.errors.BackendError
            Raised when this failed to communicate with the cache&#39;s
            backend. This may be a sign of underlying network or database
            issues.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sake.redis.VoiceStateCache" href="redis.html#sake.redis.VoiceStateCache">VoiceStateCache</a></li>
<li><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></li>
<li><a title="sake.traits.RefVoiceStateCache" href="#sake.traits.RefVoiceStateCache">RefVoiceStateCache</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sake.traits.VoiceStateCache.clear_voice_states"><code class="name flex">
<span>async def <span class="ident">clear_voice_states</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the voice states cache store.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no guarantee that this operation will be complete before
the returned coroutine finishes.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this call failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_voice_states(self) -&gt; None:
    &#34;&#34;&#34;Empty the voice states cache store.

    !!! note
        There is no guarantee that this operation will be complete before
        the returned coroutine finishes.

    Raises
    ------
    sake.errors.BackendError
        Raised when this call failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.VoiceStateCache.delete_voice_state"><code class="name flex">
<span>async def <span class="ident">delete_voice_state</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a voice state from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to remove a cached voice state for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to remove a cached voice state for.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete methods do not raise <code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code> when the
targeted entity doesn't exist.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_voice_state(self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /) -&gt; None:
    &#34;&#34;&#34;Remove a voice state from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to remove a cached voice state for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to remove a cached voice state for.

    !!! note
        Delete methods do not raise `sake.errors.EntryNotFound` when the
        targeted entity doesn&#39;t exist.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.VoiceStateCache.get_voice_state"><code class="name flex">
<span>async def <span class="ident">get_voice_state</span></span>(<span>self, guild_id:Â snowflakes.Snowflakeish, user_id:Â snowflakes.Snowflakeish, /) â€‘>Â voices.VoiceState</span>
</code></dt>
<dd>
<div class="desc"><p>Get a voice state from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the guild to get a cached voice state for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>hikari.snowflakes.Snowflakeish</code></dt>
<dd>The ID of the user to get a cached voice state for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hikari.voices.VoiceState</code></dt>
<dd>The object of the voice state fetched from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.EntryNotFound" href="errors.html#sake.errors.EntryNotFound">EntryNotFound</a></code></dt>
<dd>Raised when the targeted entity wasn't found.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_voice_state(
    self, guild_id: snowflakes.Snowflakeish, user_id: snowflakes.Snowflakeish, /
) -&gt; voices.VoiceState:
    &#34;&#34;&#34;Get a voice state from the cache.

    Parameters
    ----------
    guild_id : hikari.snowflakes.Snowflakeish
        The ID of the guild to get a cached voice state for.
    user_id : hikari.snowflakes.Snowflakeish
        The ID of the user to get a cached voice state for.

    Returns
    -------
    hikari.voices.VoiceState
        The object of the voice state fetched from the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.EntryNotFound
        Raised when the targeted entity wasn&#39;t found.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.VoiceStateCache.iter_voice_states"><code class="name flex">
<span>def <span class="ident">iter_voice_states</span></span>(<span>self) â€‘>Â <a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[voices.VoiceState]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over the voice states stored in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a>[hikari.voices.VoiceState]</code></dt>
<dd>An async iterator of the voice states stored in the cache.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Errors won't be raised by the initial call to this method but rather
while iterating over the returned asynchronous iterator.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's backend.
This may be a sign of underlying network or database issues.</dd>
<dt><code><a title="sake.errors.InvalidDataFound" href="errors.html#sake.errors.InvalidDataFound">InvalidDataFound</a></code></dt>
<dd>Raised when the data retrieved from the backend datastore was
either invalid for this implementation or corrupt.
This may be a sign of multiple sake versions or implementations
being used with the same backend store.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_voice_states(self) -&gt; CacheIterator[voices.VoiceState]:
    &#34;&#34;&#34;Iterate over the voice states stored in the cache.

    Returns
    -------
    CacheIterator[hikari.voices.VoiceState]
        An async iterator of the voice states stored in the cache.

    !!! note
        Errors won&#39;t be raised by the initial call to this method but rather
        while iterating over the returned asynchronous iterator.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s backend.
        This may be a sign of underlying network or database issues.
    sake.errors.InvalidDataFound
        Raised when the data retrieved from the backend datastore was
        either invalid for this implementation or corrupt.
        This may be a sign of multiple sake versions or implementations
        being used with the same backend store.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="sake.traits.VoiceStateCache.set_voice_state"><code class="name flex">
<span>async def <span class="ident">set_voice_state</span></span>(<span>self, voice_state:Â voices.VoiceState, /) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a voice state to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>voice_state</code></strong> :&ensp;<code>hikari.voices.VoiceState</code></dt>
<dd>The voice state to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="sake.errors.BackendError" href="errors.html#sake.errors.BackendError">BackendError</a></code></dt>
<dd>Raised when this failed to communicate with the cache's
backend. This may be a sign of underlying network or database
issues.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
    &#34;&#34;&#34;Add a voice state to the cache.

    Parameters
    ----------
    voice_state : hikari.voices.VoiceState
        The voice state to add to the cache.

    Raises
    ------
    sake.errors.BackendError
        Raised when this failed to communicate with the cache&#39;s
        backend. This may be a sign of underlying network or database
        issues.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sake" href="index.html">sake</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sake.traits.Cache" href="#sake.traits.Cache">Cache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.traits.CacheIterator" href="#sake.traits.CacheIterator">CacheIterator</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.CacheIterator.len" href="#sake.traits.CacheIterator.len">len</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.EmojiCache" href="#sake.traits.EmojiCache">EmojiCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.EmojiCache.clear_emojis" href="#sake.traits.EmojiCache.clear_emojis">clear_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.delete_emoji" href="#sake.traits.EmojiCache.delete_emoji">delete_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.get_emoji" href="#sake.traits.EmojiCache.get_emoji">get_emoji</a></code></li>
<li><code><a title="sake.traits.EmojiCache.iter_emojis" href="#sake.traits.EmojiCache.iter_emojis">iter_emojis</a></code></li>
<li><code><a title="sake.traits.EmojiCache.set_emoji" href="#sake.traits.EmojiCache.set_emoji">set_emoji</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.GuildCache.clear_guilds" href="#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.delete_guild" href="#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.get_guild" href="#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.iter_guilds" href="#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.set_guild" href="#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.GuildCache" href="#sake.traits.GuildCache">GuildCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.GuildCache.clear_guilds" href="#sake.traits.GuildCache.clear_guilds">clear_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.delete_guild" href="#sake.traits.GuildCache.delete_guild">delete_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.get_guild" href="#sake.traits.GuildCache.get_guild">get_guild</a></code></li>
<li><code><a title="sake.traits.GuildCache.iter_guilds" href="#sake.traits.GuildCache.iter_guilds">iter_guilds</a></code></li>
<li><code><a title="sake.traits.GuildCache.set_guild" href="#sake.traits.GuildCache.set_guild">set_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.GuildChannelCache" href="#sake.traits.GuildChannelCache">GuildChannelCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.GuildChannelCache.clear_guild_channels" href="#sake.traits.GuildChannelCache.clear_guild_channels">clear_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.delete_guild_channel" href="#sake.traits.GuildChannelCache.delete_guild_channel">delete_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.get_guild_channel" href="#sake.traits.GuildChannelCache.get_guild_channel">get_guild_channel</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.iter_guild_channels" href="#sake.traits.GuildChannelCache.iter_guild_channels">iter_guild_channels</a></code></li>
<li><code><a title="sake.traits.GuildChannelCache.set_guild_channel" href="#sake.traits.GuildChannelCache.set_guild_channel">set_guild_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.IntegrationCache" href="#sake.traits.IntegrationCache">IntegrationCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.IntegrationCache.clear_integrations" href="#sake.traits.IntegrationCache.clear_integrations">clear_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.delete_integration" href="#sake.traits.IntegrationCache.delete_integration">delete_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.get_integration" href="#sake.traits.IntegrationCache.get_integration">get_integration</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.iter_integrations" href="#sake.traits.IntegrationCache.iter_integrations">iter_integrations</a></code></li>
<li><code><a title="sake.traits.IntegrationCache.set_integration" href="#sake.traits.IntegrationCache.set_integration">set_integration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.InviteCache" href="#sake.traits.InviteCache">InviteCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.InviteCache.clear_invites" href="#sake.traits.InviteCache.clear_invites">clear_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.delete_invite" href="#sake.traits.InviteCache.delete_invite">delete_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.get_invite" href="#sake.traits.InviteCache.get_invite">get_invite</a></code></li>
<li><code><a title="sake.traits.InviteCache.iter_invites" href="#sake.traits.InviteCache.iter_invites">iter_invites</a></code></li>
<li><code><a title="sake.traits.InviteCache.set_invite" href="#sake.traits.InviteCache.set_invite">set_invite</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.MeCache.delete_me" href="#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.traits.MeCache.get_me" href="#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.traits.MeCache.set_me" href="#sake.traits.MeCache.set_me">set_me</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.MeCache" href="#sake.traits.MeCache">MeCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.MeCache.delete_me" href="#sake.traits.MeCache.delete_me">delete_me</a></code></li>
<li><code><a title="sake.traits.MeCache.get_me" href="#sake.traits.MeCache.get_me">get_me</a></code></li>
<li><code><a title="sake.traits.MeCache.set_me" href="#sake.traits.MeCache.set_me">set_me</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.MemberCache" href="#sake.traits.MemberCache">MemberCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.MemberCache.clear_members" href="#sake.traits.MemberCache.clear_members">clear_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.delete_member" href="#sake.traits.MemberCache.delete_member">delete_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.get_member" href="#sake.traits.MemberCache.get_member">get_member</a></code></li>
<li><code><a title="sake.traits.MemberCache.iter_members" href="#sake.traits.MemberCache.iter_members">iter_members</a></code></li>
<li><code><a title="sake.traits.MemberCache.set_member" href="#sake.traits.MemberCache.set_member">set_member</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.MessageCache" href="#sake.traits.MessageCache">MessageCache</a></code></h4>
<ul class="two-column">
<li><code><a title="sake.traits.MessageCache.clear_messages" href="#sake.traits.MessageCache.clear_messages">clear_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.delete_message" href="#sake.traits.MessageCache.delete_message">delete_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.get_message" href="#sake.traits.MessageCache.get_message">get_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.iter_messages" href="#sake.traits.MessageCache.iter_messages">iter_messages</a></code></li>
<li><code><a title="sake.traits.MessageCache.set_message" href="#sake.traits.MessageCache.set_message">set_message</a></code></li>
<li><code><a title="sake.traits.MessageCache.update_message" href="#sake.traits.MessageCache.update_message">update_message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.PresenceCache" href="#sake.traits.PresenceCache">PresenceCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.PresenceCache.clear_presences" href="#sake.traits.PresenceCache.clear_presences">clear_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.delete_presence" href="#sake.traits.PresenceCache.delete_presence">delete_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.get_presence" href="#sake.traits.PresenceCache.get_presence">get_presence</a></code></li>
<li><code><a title="sake.traits.PresenceCache.iter_presences" href="#sake.traits.PresenceCache.iter_presences">iter_presences</a></code></li>
<li><code><a title="sake.traits.PresenceCache.set_presence" href="#sake.traits.PresenceCache.set_presence">set_presence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefCache" href="#sake.traits.RefCache">RefCache</a></code></h4>
</li>
<li>
<h4><code><a title="sake.traits.RefEmojiCache" href="#sake.traits.RefEmojiCache">RefEmojiCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefEmojiCache.clear_emojis_for_guild" href="#sake.traits.RefEmojiCache.clear_emojis_for_guild">clear_emojis_for_guild</a></code></li>
<li><code><a title="sake.traits.RefEmojiCache.iter_emojis_for_guild" href="#sake.traits.RefEmojiCache.iter_emojis_for_guild">iter_emojis_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefGuildChannelCache" href="#sake.traits.RefGuildChannelCache">RefGuildChannelCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild" href="#sake.traits.RefGuildChannelCache.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a></code></li>
<li><code><a title="sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild" href="#sake.traits.RefGuildChannelCache.iter_guild_channels_for_guild">iter_guild_channels_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefIntegrationCache" href="#sake.traits.RefIntegrationCache">RefIntegrationCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefIntegrationCache.clear_integrations_for_application" href="#sake.traits.RefIntegrationCache.clear_integrations_for_application">clear_integrations_for_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.clear_integrations_for_guild" href="#sake.traits.RefIntegrationCache.clear_integrations_for_guild">clear_integrations_for_guild</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.delete_integration_by_application" href="#sake.traits.RefIntegrationCache.delete_integration_by_application">delete_integration_by_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.get_integration_by_application" href="#sake.traits.RefIntegrationCache.get_integration_by_application">get_integration_by_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.iter_integrations_for_application" href="#sake.traits.RefIntegrationCache.iter_integrations_for_application">iter_integrations_for_application</a></code></li>
<li><code><a title="sake.traits.RefIntegrationCache.iter_integrations_for_guild" href="#sake.traits.RefIntegrationCache.iter_integrations_for_guild">iter_integrations_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefInviteCache" href="#sake.traits.RefInviteCache">RefInviteCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefInviteCache.clear_invites_for_channel" href="#sake.traits.RefInviteCache.clear_invites_for_channel">clear_invites_for_channel</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.clear_invites_for_guild" href="#sake.traits.RefInviteCache.clear_invites_for_guild">clear_invites_for_guild</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.iter_invites_for_channel" href="#sake.traits.RefInviteCache.iter_invites_for_channel">iter_invites_for_channel</a></code></li>
<li><code><a title="sake.traits.RefInviteCache.iter_invites_for_guild" href="#sake.traits.RefInviteCache.iter_invites_for_guild">iter_invites_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefMemberCache" href="#sake.traits.RefMemberCache">RefMemberCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefMemberCache.clear_members_for_guild" href="#sake.traits.RefMemberCache.clear_members_for_guild">clear_members_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.clear_members_for_user" href="#sake.traits.RefMemberCache.clear_members_for_user">clear_members_for_user</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.iter_members_for_guild" href="#sake.traits.RefMemberCache.iter_members_for_guild">iter_members_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMemberCache.iter_members_for_user" href="#sake.traits.RefMemberCache.iter_members_for_user">iter_members_for_user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefMessageCache" href="#sake.traits.RefMessageCache">RefMessageCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_author" href="#sake.traits.RefMessageCache.clear_messages_for_author">clear_messages_for_author</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_channel" href="#sake.traits.RefMessageCache.clear_messages_for_channel">clear_messages_for_channel</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.clear_messages_for_guild" href="#sake.traits.RefMessageCache.clear_messages_for_guild">clear_messages_for_guild</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_message_for_channel" href="#sake.traits.RefMessageCache.iter_message_for_channel">iter_message_for_channel</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_messages_for_author" href="#sake.traits.RefMessageCache.iter_messages_for_author">iter_messages_for_author</a></code></li>
<li><code><a title="sake.traits.RefMessageCache.iter_messages_for_guild" href="#sake.traits.RefMessageCache.iter_messages_for_guild">iter_messages_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefPresenceCache" href="#sake.traits.RefPresenceCache">RefPresenceCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefPresenceCache.clear_presences_for_guild" href="#sake.traits.RefPresenceCache.clear_presences_for_guild">clear_presences_for_guild</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.clear_presences_for_user" href="#sake.traits.RefPresenceCache.clear_presences_for_user">clear_presences_for_user</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.iter_presences_for_guild" href="#sake.traits.RefPresenceCache.iter_presences_for_guild">iter_presences_for_guild</a></code></li>
<li><code><a title="sake.traits.RefPresenceCache.iter_presences_for_user" href="#sake.traits.RefPresenceCache.iter_presences_for_user">iter_presences_for_user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefRoleCache" href="#sake.traits.RefRoleCache">RefRoleCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefRoleCache.clear_roles_for_guild" href="#sake.traits.RefRoleCache.clear_roles_for_guild">clear_roles_for_guild</a></code></li>
<li><code><a title="sake.traits.RefRoleCache.iter_roles_for_guild" href="#sake.traits.RefRoleCache.iter_roles_for_guild">iter_roles_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RefVoiceStateCache" href="#sake.traits.RefVoiceStateCache">RefVoiceStateCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RefVoiceStateCache.clear_voice_states_for_channel" href="#sake.traits.RefVoiceStateCache.clear_voice_states_for_channel">clear_voice_states_for_channel</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.clear_voice_states_for_guild" href="#sake.traits.RefVoiceStateCache.clear_voice_states_for_guild">clear_voice_states_for_guild</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.iter_voice_states_for_channel" href="#sake.traits.RefVoiceStateCache.iter_voice_states_for_channel">iter_voice_states_for_channel</a></code></li>
<li><code><a title="sake.traits.RefVoiceStateCache.iter_voice_states_for_guild" href="#sake.traits.RefVoiceStateCache.iter_voice_states_for_guild">iter_voice_states_for_guild</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.Resource" href="#sake.traits.Resource">Resource</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.Resource.close" href="#sake.traits.Resource.close">close</a></code></li>
<li><code><a title="sake.traits.Resource.open" href="#sake.traits.Resource.open">open</a></code></li>
<li><code><a title="sake.traits.Resource.subscribe_listeners" href="#sake.traits.Resource.subscribe_listeners">subscribe_listeners</a></code></li>
<li><code><a title="sake.traits.Resource.unsubscribe_listeners" href="#sake.traits.Resource.unsubscribe_listeners">unsubscribe_listeners</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.RoleCache" href="#sake.traits.RoleCache">RoleCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.RoleCache.clear_roles" href="#sake.traits.RoleCache.clear_roles">clear_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.delete_role" href="#sake.traits.RoleCache.delete_role">delete_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.get_role" href="#sake.traits.RoleCache.get_role">get_role</a></code></li>
<li><code><a title="sake.traits.RoleCache.iter_roles" href="#sake.traits.RoleCache.iter_roles">iter_roles</a></code></li>
<li><code><a title="sake.traits.RoleCache.set_role" href="#sake.traits.RoleCache.set_role">set_role</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.UserCache.clear_users" href="#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.traits.UserCache.delete_user" href="#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.traits.UserCache.get_user" href="#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.traits.UserCache.iter_users" href="#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.traits.UserCache.set_user" href="#sake.traits.UserCache.set_user">set_user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.UserCache" href="#sake.traits.UserCache">UserCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.UserCache.clear_users" href="#sake.traits.UserCache.clear_users">clear_users</a></code></li>
<li><code><a title="sake.traits.UserCache.delete_user" href="#sake.traits.UserCache.delete_user">delete_user</a></code></li>
<li><code><a title="sake.traits.UserCache.get_user" href="#sake.traits.UserCache.get_user">get_user</a></code></li>
<li><code><a title="sake.traits.UserCache.iter_users" href="#sake.traits.UserCache.iter_users">iter_users</a></code></li>
<li><code><a title="sake.traits.UserCache.set_user" href="#sake.traits.UserCache.set_user">set_user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sake.traits.VoiceStateCache" href="#sake.traits.VoiceStateCache">VoiceStateCache</a></code></h4>
<ul class="">
<li><code><a title="sake.traits.VoiceStateCache.clear_voice_states" href="#sake.traits.VoiceStateCache.clear_voice_states">clear_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.delete_voice_state" href="#sake.traits.VoiceStateCache.delete_voice_state">delete_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.get_voice_state" href="#sake.traits.VoiceStateCache.get_voice_state">get_voice_state</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.iter_voice_states" href="#sake.traits.VoiceStateCache.iter_voice_states">iter_voice_states</a></code></li>
<li><code><a title="sake.traits.VoiceStateCache.set_voice_state" href="#sake.traits.VoiceStateCache.set_voice_state">set_voice_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>